// Code generated by lark_sdk_gen. DO NOT EDIT.
/**
 * Copyright 2022 chyroc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lark

import (
	"context"
	"encoding/json"
	"io"
)

// BatchSendOldRawMessage
//
// 给多个用户或者多个部门发送消息。
// **注意事项：**
// - 调用该接口需要注意
// - 应用需要启用机器人能力
// - 必须拥有**获取与发送单聊、群组消息**权限，或者**以应用的身份发消息**权限（历史版本）
// - 应用需要拥有批量发送消息权限
// - 给用户发送需要拥有 **给多个用户批量发消息** 权限
// - 给部门发送需要拥有 **给一个或多个部门的成员批量发消息** 权限
// - 应用需要拥有对所发送用户或部门的可见性
// - 通过该接口发送的消息 **不支持更新以及回复等操作**
// - 只能发送给用户，无法发送给群组
// - 异步接口，会有一定延迟，每个应用待发送的消息按顺序处理，请合理安排批量发送范围和顺序
// - 单个应用每天通过该接口发送的总消息条数不超过50万
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/ucDO1EjL3gTNx4yN4UTM
func (r *MessageService) BatchSendOldRawMessage(ctx context.Context, request *BatchSendOldRawMessageReq, options ...MethodOptionFunc) (*BatchSendOldRawMessageResp, *Response, error) {
	if r.cli.mock.mockMessageBatchSendOldRawMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#BatchSendOldRawMessage mock enable")
		return r.cli.mock.mockMessageBatchSendOldRawMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "BatchSendOldRawMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/message/v4/batch_send/",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(batchSendOldRawMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageBatchSendOldRawMessage mock MessageBatchSendOldRawMessage method
func (r *Mock) MockMessageBatchSendOldRawMessage(f func(ctx context.Context, request *BatchSendOldRawMessageReq, options ...MethodOptionFunc) (*BatchSendOldRawMessageResp, *Response, error)) {
	r.mockMessageBatchSendOldRawMessage = f
}

// UnMockMessageBatchSendOldRawMessage un-mock MessageBatchSendOldRawMessage method
func (r *Mock) UnMockMessageBatchSendOldRawMessage() {
	r.mockMessageBatchSendOldRawMessage = nil
}

// BatchSendOldRawMessageReq ...
type BatchSendOldRawMessageReq struct {
	MsgType       MsgType     `json:"msg_type,omitempty"`       // 消息类型，支持多种消息类型，详见下表。
	Content       interface{} `json:"content,omitempty"`        // 消息内容，支持除卡片消息外的多种消息内容，详见下表。
	Card          interface{} `json:"card,omitempty"`           // 卡片消息内容，注意card和content必须二选一
	DepartmentIDs []string    `json:"department_ids,omitempty"` // 支持[自定义部门ID](https://open.feishu.cn/document/ukTMukTMukTM/uYTM5UjL2ETO14iNxkTN/terminology#3c3e6267)，和open_department_id，列表长度小于等于 200  <br><br>**注**：部门下的所有子部门包含的成员也会收到消息<br>**示例值：**["3dceba33a33226","d502aaa9514059", "od-5b91c9affb665451a16b90b4be367efa"]
	OpenIDs       []string    `json:"open_ids,omitempty"`       // 用户 open_id 列表，长度小于等于 200 <br><br>**示例值：**["ou_18eac85d35a26f989317ad4f02e8bbbb","ou_461cf042d9eedaa60d445f26dc747d5e"]
	UserIDs       []string    `json:"user_ids,omitempty"`       // 用户 user_id 列表，长度小于等于 200 （对应 V3 接口的 employee_ids ）<br><br>**示例值：**["7cdcc7c2","ca51d83b"]
	UnionIDs      []string    `json:"union_ids,omitempty"`      // 用户 union_ids 列表，长度小于等于 200 <br><br>**示例值：**["on_cad4860e7af114fb4ff6c5d496d1dd76","on_gdcq860e7af114fb4ff6c5d496dabcet"]
}

// batchSendOldRawMessageResp ...
type batchSendOldRawMessageResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *BatchSendOldRawMessageResp `json:"data,omitempty"` // -
}

// BatchSendOldRawMessageResp ...
type BatchSendOldRawMessageResp struct {
	MessageID            string   `json:"message_id,omitempty"`             // 消息 ID
	InvalidDepartmentIDs []string `json:"invalid_department_ids,omitempty"` // 不合法的部门 ID 列表
	InvalidOpenIDs       []string `json:"invalid_open_ids,omitempty"`       // 不合法的 open_id 列表
	InvalidUserIDs       []string `json:"invalid_user_ids,omitempty"`       // 不合法的 user_id 列表（对应V3接口的invalid_employee_ids）
	InvalidUnionIDs      []string `json:"invalid_union_ids,omitempty"`      // 不合法的 union_id 列表
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteMessage 机器人撤回机器人自己发送的消息或群主撤回群内消息。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)  ，撤回消息时机器人仍需要在会话内
// - 机器人可以撤回单聊和群组内，自己发送 且 发送时间不超过1天(24小时)的消息
// - 若机器人要撤回群内他人发送的消息，则机器人必须是该群的群主 或者 得到群主的授权，且消息发送时间不超过1天（24小时）
// - 无法撤回通过「批量发送消息接口」发送的消息
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/delete
func (r *MessageService) DeleteMessage(ctx context.Context, request *DeleteMessageReq, options ...MethodOptionFunc) (*DeleteMessageResp, *Response, error) {
	if r.cli.mock.mockMessageDeleteMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#DeleteMessage mock enable")
		return r.cli.mock.mockMessageDeleteMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "DeleteMessage",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageDeleteMessage mock MessageDeleteMessage method
func (r *Mock) MockMessageDeleteMessage(f func(ctx context.Context, request *DeleteMessageReq, options ...MethodOptionFunc) (*DeleteMessageResp, *Response, error)) {
	r.mockMessageDeleteMessage = f
}

// UnMockMessageDeleteMessage un-mock MessageDeleteMessage method
func (r *Mock) UnMockMessageDeleteMessage() {
	r.mockMessageDeleteMessage = nil
}

// DeleteMessageReq ...
type DeleteMessageReq struct {
	MessageID string `path:"message_id" json:"-"` // 待撤回的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
}

// deleteMessageResp ...
type deleteMessageResp struct {
	Code int64              `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string             `json:"msg,omitempty"`  // 错误描述
	Data *DeleteMessageResp `json:"data,omitempty"`
}

// DeleteMessageResp ...
type DeleteMessageResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteEphemeralMessage
//
// 在群会话中删除指定用户可见的临时消息卡片<br>
// 临时卡片消息可以通过该接口进行显式删除，临时卡片消息删除后将不会在该设备上留下任何痕迹。
// **权限说明** ：需要启用机器人能力；需要机器人在会话群里
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uITOyYjLykjM24iM5IjN
func (r *MessageService) DeleteEphemeralMessage(ctx context.Context, request *DeleteEphemeralMessageReq, options ...MethodOptionFunc) (*DeleteEphemeralMessageResp, *Response, error) {
	if r.cli.mock.mockMessageDeleteEphemeralMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#DeleteEphemeralMessage mock enable")
		return r.cli.mock.mockMessageDeleteEphemeralMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "DeleteEphemeralMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/ephemeral/v1/delete",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(deleteEphemeralMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageDeleteEphemeralMessage mock MessageDeleteEphemeralMessage method
func (r *Mock) MockMessageDeleteEphemeralMessage(f func(ctx context.Context, request *DeleteEphemeralMessageReq, options ...MethodOptionFunc) (*DeleteEphemeralMessageResp, *Response, error)) {
	r.mockMessageDeleteEphemeralMessage = f
}

// UnMockMessageDeleteEphemeralMessage un-mock MessageDeleteEphemeralMessage method
func (r *Mock) UnMockMessageDeleteEphemeralMessage() {
	r.mockMessageDeleteEphemeralMessage = nil
}

// DeleteEphemeralMessageReq ...
type DeleteEphemeralMessageReq struct {
	MessageID string `json:"message_id,omitempty"` // 临时消息ID
}

// deleteEphemeralMessageResp ...
type deleteEphemeralMessageResp struct {
	Code int64                       `json:"code,omitempty"`
	Msg  string                      `json:"msg,omitempty"`
	Data *DeleteEphemeralMessageResp `json:"data,omitempty"`
}

// DeleteEphemeralMessageResp ...
type DeleteEphemeralMessageResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessage 通过 message_id 查询消息内容
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 机器人必须在群组中
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/get
func (r *MessageService) GetMessage(ctx context.Context, request *GetMessageReq, options ...MethodOptionFunc) (*GetMessageResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessage mock enable")
		return r.cli.mock.mockMessageGetMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessage",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetMessage mock MessageGetMessage method
func (r *Mock) MockMessageGetMessage(f func(ctx context.Context, request *GetMessageReq, options ...MethodOptionFunc) (*GetMessageResp, *Response, error)) {
	r.mockMessageGetMessage = f
}

// UnMockMessageGetMessage un-mock MessageGetMessage method
func (r *Mock) UnMockMessageGetMessage() {
	r.mockMessageGetMessage = nil
}

// GetMessageReq ...
type GetMessageReq struct {
	MessageID string `path:"message_id" json:"-"` // 待获取消息内容的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
}

// getMessageResp ...
type getMessageResp struct {
	Code int64           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string          `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageResp `json:"data,omitempty"`
}

// GetMessageResp ...
type GetMessageResp struct {
	Items []*GetMessageRespItem `json:"items,omitempty"` // -
}

// GetMessageRespItem ...
type GetMessageRespItem struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBatchSentMessageProgress 查询批量消息整体进度
//
// 注意事项:
// * 该接口是[查询批量消息推送和阅读人数](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/batch_message/read_user)接口的加强版
// * 该接口返回的数据为查询时刻的快照数据
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/batch_message/get_progress
func (r *MessageService) GetBatchSentMessageProgress(ctx context.Context, request *GetBatchSentMessageProgressReq, options ...MethodOptionFunc) (*GetBatchSentMessageProgressResp, *Response, error) {
	if r.cli.mock.mockMessageGetBatchSentMessageProgress != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetBatchSentMessageProgress mock enable")
		return r.cli.mock.mockMessageGetBatchSentMessageProgress(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetBatchSentMessageProgress",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/batch_messages/:batch_message_id/get_progress",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getBatchSentMessageProgressResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetBatchSentMessageProgress mock MessageGetBatchSentMessageProgress method
func (r *Mock) MockMessageGetBatchSentMessageProgress(f func(ctx context.Context, request *GetBatchSentMessageProgressReq, options ...MethodOptionFunc) (*GetBatchSentMessageProgressResp, *Response, error)) {
	r.mockMessageGetBatchSentMessageProgress = f
}

// UnMockMessageGetBatchSentMessageProgress un-mock MessageGetBatchSentMessageProgress method
func (r *Mock) UnMockMessageGetBatchSentMessageProgress() {
	r.mockMessageGetBatchSentMessageProgress = nil
}

// GetBatchSentMessageProgressReq ...
type GetBatchSentMessageProgressReq struct {
	BatchMessageID string `path:"batch_message_id" json:"-"` // 待查询的批量消息的ID, 示例值："bm-0b3d5d1b2df7c6d5dbd1abe2c91e2217"
}

// getBatchSentMessageProgressResp ...
type getBatchSentMessageProgressResp struct {
	Code int64                            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 错误描述
	Data *GetBatchSentMessageProgressResp `json:"data,omitempty"`
}

// GetBatchSentMessageProgressResp ...
type GetBatchSentMessageProgressResp struct {
	BatchMessageSendProgress   []*GetBatchSentMessageProgressRespBatchMessageSendProgres   `json:"batch_message_send_progress,omitempty"`   // 消息发送进度
	BatchMessageRecallProgress []*GetBatchSentMessageProgressRespBatchMessageRecallProgres `json:"batch_message_recall_progress,omitempty"` // 消息撤回进度
}

// GetBatchSentMessageProgressRespBatchMessageSendProgres ...
type GetBatchSentMessageProgressRespBatchMessageSendProgres struct {
	ValidUserIDsCount   int64 `json:"valid_user_ids_count,omitempty"`   // 批量请求中有效的userid数量(包含机器人不可见用户),* 注： ,当valid_user_ids_count为0有两种情况：,1. 批量任务还没有开始被调度（请等待一会再调用该接口）,2. 批量发送消息时传入的所有openIDs、employeID、departmentiIDs都不包含有效的用户
	SuccessUserIDsCount int64 `json:"success_user_ids_count,omitempty"` // 已经成功给用户发送成功的消息数量,* 注：最终success_user_ids_count不一定等于valid_user_ids_count, 因为valid_user_ids_count包含了对机器人不可见的用户
	ReadUserIDsCount    int64 `json:"read_user_ids_count,omitempty"`    // 已读信息用户数量
}

// GetBatchSentMessageProgressRespBatchMessageRecallProgres ...
type GetBatchSentMessageProgressRespBatchMessageRecallProgres struct {
	Recall      bool  `json:"recall,omitempty"`       // 该条批量消息是否被执行过撤回操作
	RecallCount int64 `json:"recall_count,omitempty"` // 已经成功撤回的消息数量
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBatchSentMessageReadUser 查询批量消息推送和阅读人数
//
// 注意事项：
// - 只能查询通过[批量发送消息](https://open.feishu.cn/document/ukTMukTMukTM/ucDO1EjL3gTNx4yN4UTM)接口产生的消息
// - 该接口返回的数据为查询时刻的快照数据。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/batch_message/read_user
func (r *MessageService) GetBatchSentMessageReadUser(ctx context.Context, request *GetBatchSentMessageReadUserReq, options ...MethodOptionFunc) (*GetBatchSentMessageReadUserResp, *Response, error) {
	if r.cli.mock.mockMessageGetBatchSentMessageReadUser != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetBatchSentMessageReadUser mock enable")
		return r.cli.mock.mockMessageGetBatchSentMessageReadUser(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetBatchSentMessageReadUser",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/batch_messages/:batch_message_id/read_user",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getBatchSentMessageReadUserResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetBatchSentMessageReadUser mock MessageGetBatchSentMessageReadUser method
func (r *Mock) MockMessageGetBatchSentMessageReadUser(f func(ctx context.Context, request *GetBatchSentMessageReadUserReq, options ...MethodOptionFunc) (*GetBatchSentMessageReadUserResp, *Response, error)) {
	r.mockMessageGetBatchSentMessageReadUser = f
}

// UnMockMessageGetBatchSentMessageReadUser un-mock MessageGetBatchSentMessageReadUser method
func (r *Mock) UnMockMessageGetBatchSentMessageReadUser() {
	r.mockMessageGetBatchSentMessageReadUser = nil
}

// GetBatchSentMessageReadUserReq ...
type GetBatchSentMessageReadUserReq struct {
	BatchMessageID string `path:"batch_message_id" json:"-"` // 待查询的批量消息的ID, 示例值："bm_dc13264520392913993dd051dba21dcf"
}

// getBatchSentMessageReadUserResp ...
type getBatchSentMessageReadUserResp struct {
	Code int64                            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 错误描述
	Data *GetBatchSentMessageReadUserResp `json:"data,omitempty"`
}

// GetBatchSentMessageReadUserResp ...
type GetBatchSentMessageReadUserResp struct {
	ReadUser *GetBatchSentMessageReadUserRespReadUser `json:"read_user,omitempty"` // 批量发送消息的用户阅读情况
}

// GetBatchSentMessageReadUserRespReadUser ...
type GetBatchSentMessageReadUserRespReadUser struct {
	ReadCount  string `json:"read_count,omitempty"`  // 已读的人数
	TotalCount string `json:"total_count,omitempty"` // 推送的总人数
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageFile 获取消息中的资源文件，包括音频，视频，图片和文件，**暂不支持表情包资源下载**。当前仅支持 100M 以内的资源文件的下载。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 机器人和消息需要在同一会话中
// - 请求的 file_key 和 message_id 需要匹配
// - 暂不支持获取合并转发消息中的子消息的资源文件
// - 获取群组消息时，应用必须拥有 获取群组中所有的消息 权限
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-resource/get
func (r *MessageService) GetMessageFile(ctx context.Context, request *GetMessageFileReq, options ...MethodOptionFunc) (*GetMessageFileResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageFile != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageFile mock enable")
		return r.cli.mock.mockMessageGetMessageFile(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageFile",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/resources/:file_key",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageFileResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetMessageFile mock MessageGetMessageFile method
func (r *Mock) MockMessageGetMessageFile(f func(ctx context.Context, request *GetMessageFileReq, options ...MethodOptionFunc) (*GetMessageFileResp, *Response, error)) {
	r.mockMessageGetMessageFile = f
}

// UnMockMessageGetMessageFile un-mock MessageGetMessageFile method
func (r *Mock) UnMockMessageGetMessageFile() {
	r.mockMessageGetMessageFile = nil
}

// GetMessageFileReq ...
type GetMessageFileReq struct {
	Type      string `query:"type" json:"-"`      // 资源类型，可选"image, file“； image对应消息中的 图片，富文本消息中的图片。  file对应消息中的 文件、音频、视频、（表情包除外）, 示例值："image"
	MessageID string `path:"message_id" json:"-"` // 待查询资源对应的消息ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	FileKey   string `path:"file_key" json:"-"`   // 待查询资源的key, 示例值："file_456a92d6-c6ea-4de4-ac3f-7afcf44ac78g"
}

// getMessageFileResp ...
type getMessageFileResp struct {
	IsFile bool                `json:"is_file,omitempty"`
	Code   int64               `json:"code,omitempty"`
	Msg    string              `json:"msg,omitempty"`
	Data   *GetMessageFileResp `json:"data,omitempty"`
}

func (r *getMessageFileResp) SetReader(file io.Reader) {
	if r.Data == nil {
		r.Data = &GetMessageFileResp{}
	}
	r.Data.File = file
}

// GetMessageFileResp ...
type GetMessageFileResp struct {
	File io.Reader `json:"file,omitempty"`
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageReadUserList 查询消息的已读信息。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能查询机器人自己发送，且发送时间不超过7天的消息
// - 查询消息已读信息时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/read_users
func (r *MessageService) GetMessageReadUserList(ctx context.Context, request *GetMessageReadUserListReq, options ...MethodOptionFunc) (*GetMessageReadUserListResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageReadUserList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageReadUserList mock enable")
		return r.cli.mock.mockMessageGetMessageReadUserList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageReadUserList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/read_users",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageReadUserListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetMessageReadUserList mock MessageGetMessageReadUserList method
func (r *Mock) MockMessageGetMessageReadUserList(f func(ctx context.Context, request *GetMessageReadUserListReq, options ...MethodOptionFunc) (*GetMessageReadUserListResp, *Response, error)) {
	r.mockMessageGetMessageReadUserList = f
}

// UnMockMessageGetMessageReadUserList un-mock MessageGetMessageReadUserList method
func (r *Mock) UnMockMessageGetMessageReadUserList() {
	r.mockMessageGetMessageReadUserList = nil
}

// GetMessageReadUserListReq ...
type GetMessageReadUserListReq struct {
	UserIDType IDType  `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageSize   *int64  `query:"page_size" json:"-"`    // 此次调用中使用的分页的大小, 示例值：20, 取值范围：`1` ～ `100`
	PageToken  *string `query:"page_token" json:"-"`   // 下一页分页的token, 示例值："GxmvlNRvP0NdQZpa7yIqf_Lv_QuBwTQ8tXkX7w-irAghVD_TvuYd1aoJ1LQph86O-XImC4X9j9FhUPhXQDvtrQ=="
	MessageID  string  `path:"message_id" json:"-"`    // 待查询的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
}

// getMessageReadUserListResp ...
type getMessageReadUserListResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageReadUserListResp `json:"data,omitempty"`
}

// GetMessageReadUserListResp ...
type GetMessageReadUserListResp struct {
	Items     []*GetMessageReadUserListRespItem `json:"items,omitempty"`      // -
	HasMore   bool                              `json:"has_more,omitempty"`   // 是否还有下一页
	PageToken string                            `json:"page_token,omitempty"` // 下一页分页的token
}

// GetMessageReadUserListRespItem ...
type GetMessageReadUserListRespItem struct {
	UserIDType IDType `json:"user_id_type,omitempty"` // 用户id类型
	UserID     string `json:"user_id,omitempty"`      // 用户id
	Timestamp  string `json:"timestamp,omitempty"`    // 阅读时间
	TenantKey  string `json:"tenant_key,omitempty"`   // tenant key
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageList 获取会话（包括单聊、群组）的历史消息（聊天记录）。
//
// 接口级别权限默认只能获取单聊消息，如果需要获取群组消息，应用还必须拥有 ***获取群组中所有的消息*** 权限
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 获取消息时，机器人必须在群组中
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/list
func (r *MessageService) GetMessageList(ctx context.Context, request *GetMessageListReq, options ...MethodOptionFunc) (*GetMessageListResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageList mock enable")
		return r.cli.mock.mockMessageGetMessageList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getMessageListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetMessageList mock MessageGetMessageList method
func (r *Mock) MockMessageGetMessageList(f func(ctx context.Context, request *GetMessageListReq, options ...MethodOptionFunc) (*GetMessageListResp, *Response, error)) {
	r.mockMessageGetMessageList = f
}

// UnMockMessageGetMessageList un-mock MessageGetMessageList method
func (r *Mock) UnMockMessageGetMessageList() {
	r.mockMessageGetMessageList = nil
}

// GetMessageListReq ...
type GetMessageListReq struct {
	ContainerIDType ContainerIDType `query:"container_id_type" json:"-"` // 容器类型 ，目前可选值仅有"chat", 示例值："chat"
	ContainerID     string          `query:"container_id" json:"-"`      // 容器的id，即chat的id, 示例值："oc_234jsi43d3ssi993d43545f"
	StartTime       *string         `query:"start_time" json:"-"`        // 历史信息的起始时间（秒级时间戳）, 示例值："1609296809"
	EndTime         *string         `query:"end_time" json:"-"`          // 历史信息的结束时间（秒级时间戳）, 示例值："1608594809"
	PageToken       *string         `query:"page_token" json:"-"`        // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："GxmvlNRvP0NdQZpa7yIqf_Lv_QuBwTQ8tXkX7w-irAghVD_TvuYd1aoJ1LQph86O-XImC4X9j9FhUPhXQDvtrQ=="
	PageSize        *int64          `query:"page_size" json:"-"`         // 分页大小, 示例值：10, 最大值：`50`
}

// getMessageListResp ...
type getMessageListResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageListResp `json:"data,omitempty"`
}

// GetMessageListResp ...
type GetMessageListResp struct {
	HasMore   bool                      `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                    `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	Items     []*GetMessageListRespItem `json:"items,omitempty"`      // message[]
}

// GetMessageListRespItem ...
type GetMessageListRespItem struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateMessageReaction 给指定消息添加指定类型的表情回复（reaction即表情回复，本说明文档统一用“reaction”代称）。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 待添加reaction的消息要真实存在，不能被撤回
// - 给消息添加reaction，需要reaction的发送方（机器人或者用户）在消息所在的会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/create
func (r *MessageService) CreateMessageReaction(ctx context.Context, request *CreateMessageReactionReq, options ...MethodOptionFunc) (*CreateMessageReactionResp, *Response, error) {
	if r.cli.mock.mockMessageCreateMessageReaction != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#CreateMessageReaction mock enable")
		return r.cli.mock.mockMessageCreateMessageReaction(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "CreateMessageReaction",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/reactions",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createMessageReactionResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageCreateMessageReaction mock MessageCreateMessageReaction method
func (r *Mock) MockMessageCreateMessageReaction(f func(ctx context.Context, request *CreateMessageReactionReq, options ...MethodOptionFunc) (*CreateMessageReactionResp, *Response, error)) {
	r.mockMessageCreateMessageReaction = f
}

// UnMockMessageCreateMessageReaction un-mock MessageCreateMessageReaction method
func (r *Mock) UnMockMessageCreateMessageReaction() {
	r.mockMessageCreateMessageReaction = nil
}

// CreateMessageReactionReq ...
type CreateMessageReactionReq struct {
	MessageID    string                                `path:"message_id" json:"-"`     // 待添加reaction的消息ID, 示例值："om_a8f2294b************a1a38afaac9d"
	ReactionType *CreateMessageReactionReqReactionType `json:"reaction_type,omitempty"` // reaction资源类型
}

// CreateMessageReactionReqReactionType ...
type CreateMessageReactionReqReactionType struct {
	EmojiType string `json:"emoji_type,omitempty"` // emoji类型 [emoji类型列举](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/emojis-introduce), 示例值："SMILE"
}

// createMessageReactionResp ...
type createMessageReactionResp struct {
	Code int64                      `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                     `json:"msg,omitempty"`  // 错误描述
	Data *CreateMessageReactionResp `json:"data,omitempty"`
}

// CreateMessageReactionResp ...
type CreateMessageReactionResp struct {
	ReactionID   string                                 `json:"reaction_id,omitempty"`   // reaction资源ID
	Operator     *CreateMessageReactionRespOperator     `json:"operator,omitempty"`      // 添加reaction的操作人
	ActionTime   string                                 `json:"action_time,omitempty"`   // reaction动作的的unix timestamp(单位:ms)
	ReactionType *CreateMessageReactionRespReactionType `json:"reaction_type,omitempty"` // reaction资源类型
}

// CreateMessageReactionRespOperator ...
type CreateMessageReactionRespOperator struct {
	OperatorID   string `json:"operator_id,omitempty"`   // 操作人ID
	OperatorType string `json:"operator_type,omitempty"` // 操作人身份，用户或应用, 可选值有: `app`："app", `user`："user"
}

// CreateMessageReactionRespReactionType ...
type CreateMessageReactionRespReactionType struct {
	EmojiType string `json:"emoji_type,omitempty"` // emoji类型 [emoji类型列举](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/emojis-introduce)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteMessageReaction 删除指定消息的表情回复（reaction即表情回复，本说明文档统一用“reaction”代称）。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能删除真实存在的reaction，并且删除reaction请求的操作者必须是reaction的原始添加者
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/delete
func (r *MessageService) DeleteMessageReaction(ctx context.Context, request *DeleteMessageReactionReq, options ...MethodOptionFunc) (*DeleteMessageReactionResp, *Response, error) {
	if r.cli.mock.mockMessageDeleteMessageReaction != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#DeleteMessageReaction mock enable")
		return r.cli.mock.mockMessageDeleteMessageReaction(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "DeleteMessageReaction",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/reactions/:reaction_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteMessageReactionResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageDeleteMessageReaction mock MessageDeleteMessageReaction method
func (r *Mock) MockMessageDeleteMessageReaction(f func(ctx context.Context, request *DeleteMessageReactionReq, options ...MethodOptionFunc) (*DeleteMessageReactionResp, *Response, error)) {
	r.mockMessageDeleteMessageReaction = f
}

// UnMockMessageDeleteMessageReaction un-mock MessageDeleteMessageReaction method
func (r *Mock) UnMockMessageDeleteMessageReaction() {
	r.mockMessageDeleteMessageReaction = nil
}

// DeleteMessageReactionReq ...
type DeleteMessageReactionReq struct {
	MessageID  string `path:"message_id" json:"-"`  // 待删除reaction的消息ID, 示例值："om_8964d1b4*********2b31383276113"
	ReactionID string `path:"reaction_id" json:"-"` // 待删除reaction的资源id, 示例值："ZCaCIjUBVVWSrm5L-3ZTw*************sNa8dHVplEzzSfJVUVLMLcS_"
}

// deleteMessageReactionResp ...
type deleteMessageReactionResp struct {
	Code int64                      `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                     `json:"msg,omitempty"`  // 错误描述
	Data *DeleteMessageReactionResp `json:"data,omitempty"`
}

// DeleteMessageReactionResp ...
type DeleteMessageReactionResp struct {
	ReactionID   string                                 `json:"reaction_id,omitempty"`   // reaction资源ID
	Operator     *DeleteMessageReactionRespOperator     `json:"operator,omitempty"`      // 添加reaction的操作人
	ActionTime   string                                 `json:"action_time,omitempty"`   // reaction动作的的unix timestamp(单位:ms)
	ReactionType *DeleteMessageReactionRespReactionType `json:"reaction_type,omitempty"` // reaction资源类型
}

// DeleteMessageReactionRespOperator ...
type DeleteMessageReactionRespOperator struct {
	OperatorID   string `json:"operator_id,omitempty"`   // 操作人ID
	OperatorType string `json:"operator_type,omitempty"` // 操作人身份，用户或应用, 可选值有: `app`："app", `user`："user"
}

// DeleteMessageReactionRespReactionType ...
type DeleteMessageReactionRespReactionType struct {
	EmojiType string `json:"emoji_type,omitempty"` // emoji类型 [emoji类型列举](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/emojis-introduce)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetMessageReactionList 获取指定消息的特定类型表情回复列表（reaction即表情回复，本说明文档统一用“reaction”代称）。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 待获取reaction信息的消息要真实存在，不能被撤回
// - 获取消息的reaction，需要request的授权主体（机器人或者用户）在消息所在的会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/list
func (r *MessageService) GetMessageReactionList(ctx context.Context, request *GetMessageReactionListReq, options ...MethodOptionFunc) (*GetMessageReactionListResp, *Response, error) {
	if r.cli.mock.mockMessageGetMessageReactionList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#GetMessageReactionList mock enable")
		return r.cli.mock.mockMessageGetMessageReactionList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "GetMessageReactionList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/reactions",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getMessageReactionListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageGetMessageReactionList mock MessageGetMessageReactionList method
func (r *Mock) MockMessageGetMessageReactionList(f func(ctx context.Context, request *GetMessageReactionListReq, options ...MethodOptionFunc) (*GetMessageReactionListResp, *Response, error)) {
	r.mockMessageGetMessageReactionList = f
}

// UnMockMessageGetMessageReactionList un-mock MessageGetMessageReactionList method
func (r *Mock) UnMockMessageGetMessageReactionList() {
	r.mockMessageGetMessageReactionList = nil
}

// GetMessageReactionListReq ...
type GetMessageReactionListReq struct {
	ReactionType string  `query:"reaction_type" json:"-"` // 待查询消息reaction的类型[emoji类型列举](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/emojis-introduce), 示例值："LAUGH"
	PageToken    *string `query:"page_token" json:"-"`    // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："YhljsPiGfUgnVAg9urvRFd-BvSqRL20wMZNAWfa9xXkud6UKCybPuUgQ1vM26dj6"
	PageSize     *int64  `query:"page_size" json:"-"`     // 分页大小, 示例值：10, 最大值：`50`
	UserIDType   *IDType `query:"user_id_type" json:"-"`  // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`,, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	MessageID    string  `path:"message_id" json:"-"`     // 待获取reaction的消息ID, 示例值："om_8964d1b4*********2b31383276113"
}

// getMessageReactionListResp ...
type getMessageReactionListResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *GetMessageReactionListResp `json:"data,omitempty"`
}

// GetMessageReactionListResp ...
type GetMessageReactionListResp struct {
	Items     []*GetMessageReactionListRespItem `json:"items,omitempty"`      // 查询指定reaction_type返回的reaction列表
	HasMore   bool                              `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                            `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

// GetMessageReactionListRespItem ...
type GetMessageReactionListRespItem struct {
	ReactionID   string                                      `json:"reaction_id,omitempty"`   // reaction资源ID
	Operator     *GetMessageReactionListRespItemOperator     `json:"operator,omitempty"`      // 添加reaction的操作人
	ActionTime   string                                      `json:"action_time,omitempty"`   // reaction动作的的unix timestamp(单位:ms)
	ReactionType *GetMessageReactionListRespItemReactionType `json:"reaction_type,omitempty"` // reaction资源类型
}

// GetMessageReactionListRespItemOperator ...
type GetMessageReactionListRespItemOperator struct {
	OperatorID   string `json:"operator_id,omitempty"`   // 操作人ID
	OperatorType string `json:"operator_type,omitempty"` // 操作人身份，用户或应用, 可选值有: `app`："app", `user`："user"
}

// GetMessageReactionListRespItemReactionType ...
type GetMessageReactionListRespItemReactionType struct {
	EmojiType string `json:"emoji_type,omitempty"` // emoji类型 [emoji类型列举](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message-reaction/emojis-introduce)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// ReplyRawMessage 回复指定消息，支持文本、富文本、卡片、群名片、个人名片、图片、视频、文件等多种消息类型。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 回复私聊消息，需要机器人对用户有可用性
// - 回复群组消息，需要机器人在群中
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/reply
func (r *MessageService) ReplyRawMessage(ctx context.Context, request *ReplyRawMessageReq, options ...MethodOptionFunc) (*ReplyRawMessageResp, *Response, error) {
	if r.cli.mock.mockMessageReplyRawMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#ReplyRawMessage mock enable")
		return r.cli.mock.mockMessageReplyRawMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "ReplyRawMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/reply",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(replyRawMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageReplyRawMessage mock MessageReplyRawMessage method
func (r *Mock) MockMessageReplyRawMessage(f func(ctx context.Context, request *ReplyRawMessageReq, options ...MethodOptionFunc) (*ReplyRawMessageResp, *Response, error)) {
	r.mockMessageReplyRawMessage = f
}

// UnMockMessageReplyRawMessage un-mock MessageReplyRawMessage method
func (r *Mock) UnMockMessageReplyRawMessage() {
	r.mockMessageReplyRawMessage = nil
}

// ReplyRawMessageReq ...
type ReplyRawMessageReq struct {
	MessageID string  `path:"message_id" json:"-"` // 待回复的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	Content   string  `json:"content,omitempty"`   // 消息内容 json 格式，格式说明参考: [发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json), 示例值："{\"text\":\"<at user_id=\\\"ou_155184d1e73cbfb8973e5a9e698e74f2\\\">Tom</at> test content\"}"
	MsgType   MsgType `json:"msg_type,omitempty"`  // 消息类型，包括：text、post、image、file、audio、media、sticker、interactive、share_card、share_user, 示例值："text"
}

// replyRawMessageResp ...
type replyRawMessageResp struct {
	Code int64                `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string               `json:"msg,omitempty"`  // 错误描述
	Data *ReplyRawMessageResp `json:"data,omitempty"`
}

// ReplyRawMessageResp ...
type ReplyRawMessageResp struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendRawMessage 给指定用户或者会话发送消息，支持文本、富文本、可交互的[消息卡片](https://open.feishu.cn/document/ukTMukTMukTM/uczM3QjL3MzN04yNzcDN)、群名片、个人名片、图片、视频、音频、文件、表情包。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 给用户发送消息，需要机器人对用户有[可用性](https://open.feishu.cn/document/home/introduction-to-scope-and-authorization/availability)
// - 给群组发送消息，需要机器人在群中
// - 该接口不支持给部门成员发消息，请使用 [批量发送消息](https://open.feishu.cn/document/ukTMukTMukTM/ucDO1EjL3gTNx4yN4UTM)
// - 文本消息请求体最大不能超过150KB
// - 卡片及富文本消息请求体最大不能超过30KB
// - 消息卡片的 `update_multi`（是否为共享卡片）字段在卡片内容的`config`结构体中设置。详细参考文档[配置卡片属性](https://open.feishu.cn/document/ukTMukTMukTM/uAjNwUjLwYDM14CM2ATN)
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/create
func (r *MessageService) SendRawMessage(ctx context.Context, request *SendRawMessageReq, options ...MethodOptionFunc) (*SendRawMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendRawMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendRawMessage mock enable")
		return r.cli.mock.mockMessageSendRawMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendRawMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendRawMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendRawMessage mock MessageSendRawMessage method
func (r *Mock) MockMessageSendRawMessage(f func(ctx context.Context, request *SendRawMessageReq, options ...MethodOptionFunc) (*SendRawMessageResp, *Response, error)) {
	r.mockMessageSendRawMessage = f
}

// UnMockMessageSendRawMessage un-mock MessageSendRawMessage method
func (r *Mock) UnMockMessageSendRawMessage() {
	r.mockMessageSendRawMessage = nil
}

// SendRawMessageReq ...
type SendRawMessageReq struct {
	ReceiveIDType IDType  `query:"receive_id_type" json:"-"` // 消息接收者id类型 open_id/user_id/union_id/email/chat_id, 示例值："open_id", 可选值有: `open_id`：以open_id来识别用户([什么是 Open ID？](https://open.feishu.cn/document/home/user-identity-introduction/open-id)), `user_id`：以user_id来识别用户。需要有获取用户 userID的权限 ([什么是 User ID？](https://open.feishu.cn/document/home/user-identity-introduction/user-id)), `union_id`：以union_id来识别用户([什么是 Union ID？](https://open.feishu.cn/document/home/user-identity-introduction/union-id)), `email`：以email来识别用户。是用户的真实邮箱, `chat_id`：以chat_id来识别群聊。群ID说明请参考：[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description)
	ReceiveID     string  `json:"receive_id,omitempty"`      // 依据receive_id_type的值，填写对应的消息接收者id, 示例值："ou_7d8a6e6df7621556ce0d21922b676706ccs"
	Content       string  `json:"content,omitempty"`         // 消息内容，json结构序列化后的字符串。不同msg_type对应不同内容。消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，具体格式说明参考：[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json), 示例值："{\"text\":\"<at user_id=\\\"ou_155184d1e73cbfb8973e5a9e698e74f2\\\">Tom</at> test content\"}"
	MsgType       MsgType `json:"msg_type,omitempty"`        // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json), 示例值："text"
}

// sendRawMessageResp ...
type sendRawMessageResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *SendRawMessageResp `json:"data,omitempty"`
}

// SendRawMessageResp ...
type SendRawMessageResp struct {
	MessageID      string       `json:"message_id,omitempty"`       // 消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	RootID         string       `json:"root_id,omitempty"`          // 根消息id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	ParentID       string       `json:"parent_id,omitempty"`        // 父消息的id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
	MsgType        MsgType      `json:"msg_type,omitempty"`         // 消息类型 包括：text、post、image、file、audio、media、sticker、interactive、share_chat、share_user等，类型定义请参考[发送消息content说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)
	CreateTime     string       `json:"create_time,omitempty"`      // 消息生成的时间戳（毫秒）
	UpdateTime     string       `json:"update_time,omitempty"`      // 消息更新的时间戳（毫秒）
	Deleted        bool         `json:"deleted,omitempty"`          // 消息是否被撤回
	Updated        bool         `json:"updated,omitempty"`          // 消息是否被更新
	ChatID         string       `json:"chat_id,omitempty"`          // 所属的群
	Sender         *Sender      `json:"sender,omitempty"`           // 发送者，可以是用户或应用
	Body           *MessageBody `json:"body,omitempty"`             // 消息内容
	Mentions       []*Mention   `json:"mentions,omitempty"`         // 被@的用户或机器人的id列表
	UpperMessageID string       `json:"upper_message_id,omitempty"` // 合并转发消息中，上一层级的消息id message_id，说明参见：[消息ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/intro#ac79c1c2)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendEphemeralMessage
//
// 用于机器人在群会话中发送仅指定用户可见的消息卡片。<br>
// ## 使用场景
// 临时消息卡片多用于群聊中用户与机器人交互的中间态。例如在群聊中用户需要使用待办事项类bot创建一条提醒，bot 发送了可设置提醒日期和提醒内容的一张可交互的消息卡片，此卡片在没有设置为临时卡片的情况下为群内全员可见，即群内可看见该用户与 bot 交互的过程。而设置为临时卡片后，交互过程仅该用户可见，群内其他成员只会看到最终设置完成的提醒卡片。
// <br><br>通过临时消息卡片，可以减少消息对群聊中不相关用户的打扰，有效降低群消息的噪声。
// 需要启用机器人能力；需要机器人在会话群里。
// -  仅触发临时卡片的用户自己可见。
// - 不支持转发。
// - 只能在群聊使用。
// - 仅在用户处于在线状态的飞书客户端上可见。
// - 临时消息卡片的[呈现能力](https://open.feishu.cn/document/ukTMukTMukTM/uEjNwUjLxYDM14SM2ATN)、[交互能力](https://open.feishu.cn/document/ukTMukTMukTM/uYjNwUjL2YDM14iN2ATN)与消息卡片一致。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uETOyYjLxkjM24SM5IjN
func (r *MessageService) SendEphemeralMessage(ctx context.Context, request *SendEphemeralMessageReq, options ...MethodOptionFunc) (*SendEphemeralMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendEphemeralMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendEphemeralMessage mock enable")
		return r.cli.mock.mockMessageSendEphemeralMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendEphemeralMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/ephemeral/v1/send",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendEphemeralMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendEphemeralMessage mock MessageSendEphemeralMessage method
func (r *Mock) MockMessageSendEphemeralMessage(f func(ctx context.Context, request *SendEphemeralMessageReq, options ...MethodOptionFunc) (*SendEphemeralMessageResp, *Response, error)) {
	r.mockMessageSendEphemeralMessage = f
}

// UnMockMessageSendEphemeralMessage un-mock MessageSendEphemeralMessage method
func (r *Mock) UnMockMessageSendEphemeralMessage() {
	r.mockMessageSendEphemeralMessage = nil
}

// SendEphemeralMessageReq ...
type SendEphemeralMessageReq struct {
	ChatID  string              `json:"chat_id,omitempty"`  // 发送临时消息的群ID可通过事件推送获取
	OpenID  string              `json:"open_id,omitempty"`  // 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id（id介绍详见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)） 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
	UserID  string              `json:"user_id,omitempty"`  // 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id（id介绍详见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)） 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
	Email   string              `json:"email,omitempty"`    // 指定发送临时消息卡片的用户，其他人将无法看到临时消息卡片，只需要填 open_id、email、user_id（id介绍详见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)） 中的一个即可。服务端依次读取字段的顺序为 **open_id** > **user_id** > **email**
	MsgType MsgType             `json:"msg_type,omitempty"` // 消息的类型，此处固定填 "interactive"
	Card    *MessageContentCard `json:"card,omitempty"`     // 消息卡片的描述内容，具体参考 [基础结构](https://open.feishu.cn/document/ukTMukTMukTM/uEjNwUjLxYDM14SM2ATN)
}

// sendEphemeralMessageResp ...
type sendEphemeralMessageResp struct {
	Code int64                     `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 返回码描述
	Data *SendEphemeralMessageResp `json:"data,omitempty"` // -
}

// SendEphemeralMessageResp ...
type SendEphemeralMessageResp struct {
	MessageID string `json:"message_id,omitempty"` // 消息 ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendRawMessageOld
//
// 给指定用户或者会话发送文本消息，其中会话包括私聊会话和群会话。
// 需要启用机器人能力；私聊会话时机器人需要拥有对用户的可见性，群会话需要机器人在群里
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uUjNz4SN2MjL1YzM
func (r *MessageService) SendRawMessageOld(ctx context.Context, request *SendRawMessageOldReq, options ...MethodOptionFunc) (*SendRawMessageOldResp, *Response, error) {
	if r.cli.mock.mockMessageSendRawMessageOld != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendRawMessageOld mock enable")
		return r.cli.mock.mockMessageSendRawMessageOld(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendRawMessageOld",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/message/v4/send/",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendRawMessageOldResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendRawMessageOld mock MessageSendRawMessageOld method
func (r *Mock) MockMessageSendRawMessageOld(f func(ctx context.Context, request *SendRawMessageOldReq, options ...MethodOptionFunc) (*SendRawMessageOldResp, *Response, error)) {
	r.mockMessageSendRawMessageOld = f
}

// UnMockMessageSendRawMessageOld un-mock MessageSendRawMessageOld method
func (r *Mock) UnMockMessageSendRawMessageOld() {
	r.mockMessageSendRawMessageOld = nil
}

// SendRawMessageOldReq ...
type SendRawMessageOldReq struct {
	ChatID  string                       `json:"chat_id,omitempty"`  // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	OpenID  string                       `json:"open_id,omitempty"`  // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	UserID  string                       `json:"user_id,omitempty"`  // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	Email   string                       `json:"email,omitempty"`    // 给用户发私聊消息，只需要填 open_id、email、user_id 中的一个即可，向群里发消息使用群的 chat_id。服务端依次读取字段的顺序为 chat_id > open_id > user_id > email   ( user_id 对应V3接口的 employee_id , chat_id 对应V3的 open_chat_id )
	RootID  *string                      `json:"root_id,omitempty"`  // 如果需要回复某条消息，填对应消息的消息 ID
	MsgType MsgType                      `json:"msg_type,omitempty"` // 消息类型，此处固定填 "text"
	Content *SendRawMessageOldReqContent `json:"content,omitempty"`  // 消息内容
}

// SendRawMessageOldReqContent ...
type SendRawMessageOldReqContent struct {
	Text     string                 `json:"text,omitempty"`      // 文本消息内容，文本消息中可以 at 个人或全体成员<br>at 全体成员：<at user_id="all">  </at> <br> at 个人：<at user_id="ou_xxxxxxx"></at>，user_id 为用户 user_id或者open_id
	ImageKey string                 `json:"image_key,omitempty"` //  image_key 可以通过图片上传接口获得
	Post     *MessageContentPostAll `json:"post,omitempty"`      // 富文本消息
}

// sendRawMessageOldResp ...
type sendRawMessageOldResp struct {
	Code int64                  `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 返回码描述
	Data *SendRawMessageOldResp `json:"data,omitempty"` // -
}

// SendRawMessageOldResp ...
type SendRawMessageOldResp struct {
	MessageID string `json:"message_id,omitempty"` // 消息 ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendUrgentAppMessage 对指定消息进行应用内加急。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能加急机器人自己发送的消息
// - 加急时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/urgent_app
func (r *MessageService) SendUrgentAppMessage(ctx context.Context, request *SendUrgentAppMessageReq, options ...MethodOptionFunc) (*SendUrgentAppMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendUrgentAppMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendUrgentAppMessage mock enable")
		return r.cli.mock.mockMessageSendUrgentAppMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendUrgentAppMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/urgent_app",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendUrgentAppMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendUrgentAppMessage mock MessageSendUrgentAppMessage method
func (r *Mock) MockMessageSendUrgentAppMessage(f func(ctx context.Context, request *SendUrgentAppMessageReq, options ...MethodOptionFunc) (*SendUrgentAppMessageResp, *Response, error)) {
	r.mockMessageSendUrgentAppMessage = f
}

// UnMockMessageSendUrgentAppMessage un-mock MessageSendUrgentAppMessage method
func (r *Mock) UnMockMessageSendUrgentAppMessage() {
	r.mockMessageSendUrgentAppMessage = nil
}

// SendUrgentAppMessageReq ...
type SendUrgentAppMessageReq struct {
	UserIDType IDType   `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	MessageID  string   `path:"message_id" json:"-"`    // 待加急的消息ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	UserIDList []string `json:"user_id_list,omitempty"` // 目标用户的ID。列表不可为空。, 示例值：["ou_6yf8af6bgb9100449565764t3382b168"]
}

// sendUrgentAppMessageResp ...
type sendUrgentAppMessageResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *SendUrgentAppMessageResp `json:"data,omitempty"`
}

// SendUrgentAppMessageResp ...
type SendUrgentAppMessageResp struct {
	InvalidUserIDList []string `json:"invalid_user_id_list,omitempty"` // 无效的用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendUrgentPhoneMessage 对指定消息进行应用内加急与电话加急
//
// 特别说明：
// - 通过接口产生的电话加急将消耗企业的加急额度，请慎重调用。
// - 通过租户管理后台-费用中心-短信/电话加急 可以查看当前额度。
// - 默认接口限流为50 QPS，请谨慎调用。
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能加急机器人自己发送的消息
// - 加急时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/urgent_phone
func (r *MessageService) SendUrgentPhoneMessage(ctx context.Context, request *SendUrgentPhoneMessageReq, options ...MethodOptionFunc) (*SendUrgentPhoneMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendUrgentPhoneMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendUrgentPhoneMessage mock enable")
		return r.cli.mock.mockMessageSendUrgentPhoneMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendUrgentPhoneMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/urgent_phone",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendUrgentPhoneMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendUrgentPhoneMessage mock MessageSendUrgentPhoneMessage method
func (r *Mock) MockMessageSendUrgentPhoneMessage(f func(ctx context.Context, request *SendUrgentPhoneMessageReq, options ...MethodOptionFunc) (*SendUrgentPhoneMessageResp, *Response, error)) {
	r.mockMessageSendUrgentPhoneMessage = f
}

// UnMockMessageSendUrgentPhoneMessage un-mock MessageSendUrgentPhoneMessage method
func (r *Mock) UnMockMessageSendUrgentPhoneMessage() {
	r.mockMessageSendUrgentPhoneMessage = nil
}

// SendUrgentPhoneMessageReq ...
type SendUrgentPhoneMessageReq struct {
	UserIDType IDType   `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	MessageID  string   `path:"message_id" json:"-"`    // 待加急的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	UserIDList []string `json:"user_id_list,omitempty"` // 目标用户的ID。列表不可为空。, 示例值：["ou_6yf8af6bgb9100449565764t3382b168"]
}

// sendUrgentPhoneMessageResp ...
type sendUrgentPhoneMessageResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *SendUrgentPhoneMessageResp `json:"data,omitempty"`
}

// SendUrgentPhoneMessageResp ...
type SendUrgentPhoneMessageResp struct {
	InvalidUserIDList []string `json:"invalid_user_id_list,omitempty"` // 无效的用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SendUrgentSmsMessage 对指定消息进行应用内加急与短信加急。
//
// 特别说明：
// - 通过接口产生的短信加急将消耗企业的加急额度，请慎重调用。
// - 通过租户管理后台-费用中心-短信/电话加急 可以查看当前额度。
// - 默认接口限流为50 QPS，请谨慎调用。
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 只能加急机器人自己发送的消息
// - 加急时机器人仍需要在会话内
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/urgent_sms
func (r *MessageService) SendUrgentSmsMessage(ctx context.Context, request *SendUrgentSmsMessageReq, options ...MethodOptionFunc) (*SendUrgentSmsMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendUrgentSmsMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#SendUrgentSmsMessage mock enable")
		return r.cli.mock.mockMessageSendUrgentSmsMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendUrgentSmsMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id/urgent_sms",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendUrgentSmsMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendUrgentSmsMessage mock MessageSendUrgentSmsMessage method
func (r *Mock) MockMessageSendUrgentSmsMessage(f func(ctx context.Context, request *SendUrgentSmsMessageReq, options ...MethodOptionFunc) (*SendUrgentSmsMessageResp, *Response, error)) {
	r.mockMessageSendUrgentSmsMessage = f
}

// UnMockMessageSendUrgentSmsMessage un-mock MessageSendUrgentSmsMessage method
func (r *Mock) UnMockMessageSendUrgentSmsMessage() {
	r.mockMessageSendUrgentSmsMessage = nil
}

// SendUrgentSmsMessageReq ...
type SendUrgentSmsMessageReq struct {
	UserIDType IDType   `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	MessageID  string   `path:"message_id" json:"-"`    // 待加急的消息ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	UserIDList []string `json:"user_id_list,omitempty"` // 目标用户的ID。列表不可为空。, 示例值：["ou_6yf8af6bgb9100449565764t3382b168"]
}

// sendUrgentSmsMessageResp ...
type sendUrgentSmsMessageResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *SendUrgentSmsMessageResp `json:"data,omitempty"`
}

// SendUrgentSmsMessageResp ...
type SendUrgentSmsMessageResp struct {
	InvalidUserIDList []string `json:"invalid_user_id_list,omitempty"` // 无效的用户ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateMessage 更新应用已发送的消息卡片内容。
//
// 注意事项:
// - 需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
// - 当前仅支持更新 ***卡片消息***
// - 只支持对所有人都更新的[「共享卡片」](ukTMukTMukTM/uAjNwUjLwYDM14CM2ATN)，也即需要在卡片的`config`属性中，显式声明`"update_multi":true`。<br>如果你只想更新特定人的消息卡片，必须要用户在卡片操作交互后触发，开发文档参考[「独享卡片」](https://open.feishu.cn/document/ukTMukTMukTM/uYjNwUjL2YDM14iN2ATN#49904b71)
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/message/patch
func (r *MessageService) UpdateMessage(ctx context.Context, request *UpdateMessageReq, options ...MethodOptionFunc) (*UpdateMessageResp, *Response, error) {
	if r.cli.mock.mockMessageUpdateMessage != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#UpdateMessage mock enable")
		return r.cli.mock.mockMessageUpdateMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "UpdateMessage",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/messages/:message_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageUpdateMessage mock MessageUpdateMessage method
func (r *Mock) MockMessageUpdateMessage(f func(ctx context.Context, request *UpdateMessageReq, options ...MethodOptionFunc) (*UpdateMessageResp, *Response, error)) {
	r.mockMessageUpdateMessage = f
}

// UnMockMessageUpdateMessage un-mock MessageUpdateMessage method
func (r *Mock) UnMockMessageUpdateMessage() {
	r.mockMessageUpdateMessage = nil
}

// UpdateMessageReq ...
type UpdateMessageReq struct {
	MessageID string `path:"message_id" json:"-"` // 待更新的消息的ID, 示例值："om_dc13264520392913993dd051dba21dcf"
	Content   string `json:"content,omitempty"`   // 消息内容 json 格式，[发送消息 content 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/message/create_json)，参考文档中的卡片格式, 示例值："参考链接"
}

// updateMessageResp ...
type updateMessageResp struct {
	Code int64              `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string             `json:"msg,omitempty"`  // 错误描述
	Data *UpdateMessageResp `json:"data,omitempty"`
}

// UpdateMessageResp ...
type UpdateMessageResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateMessageDelay
//
// 用于用户交互完成后延后更新消息卡片
// ### 使用场景
// 1. 用户点击卡片后业务方需要处理较长时间，无法在3s内及时返回需要展示的卡片内容
// 2. 指定只更新一部分收到这张卡片成员（同一个`message_id`）看到的卡片内容
// - 需要用户主动交互触发，不支持无条件更新
// - 延迟更新使用的token有效期为30分钟，超时则无法更新卡片
// - 调用延迟更新接口需要晚于同步返回，否则会出现不可预测行为<br>服务端处理时，可先立即 return 空串，再在30分钟内调用延迟更新接口更新卡片
// - 只能更新用户交互对应卡片，不允许更新其他卡片
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uMDO1YjLzgTN24yM4UjN
func (r *MessageService) UpdateMessageDelay(ctx context.Context, request *UpdateMessageDelayReq, options ...MethodOptionFunc) (*UpdateMessageDelayResp, *Response, error) {
	if r.cli.mock.mockMessageUpdateMessageDelay != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Message#UpdateMessageDelay mock enable")
		return r.cli.mock.mockMessageUpdateMessageDelay(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "UpdateMessageDelay",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/interactive/v1/card/update",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(updateMessageDelayResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageUpdateMessageDelay mock MessageUpdateMessageDelay method
func (r *Mock) MockMessageUpdateMessageDelay(f func(ctx context.Context, request *UpdateMessageDelayReq, options ...MethodOptionFunc) (*UpdateMessageDelayResp, *Response, error)) {
	r.mockMessageUpdateMessageDelay = f
}

// UnMockMessageUpdateMessageDelay un-mock MessageUpdateMessageDelay method
func (r *Mock) UnMockMessageUpdateMessageDelay() {
	r.mockMessageUpdateMessageDelay = nil
}

// UpdateMessageDelayReq ...
type UpdateMessageDelayReq struct {
	Token string                     `json:"token,omitempty"` // 用于更新卡片的token，不是tenant_access_token（可通过[卡片交互返回内容](https://open.feishu.cn/document/ukTMukTMukTM/uEzNwUjLxcDM14SM3ATN)获取）
	Card  *UpdateMessageDelayReqCard `json:"card,omitempty"`  // 消息卡片的描述内容，具体参考[卡片结构](https://open.feishu.cn/document/ukTMukTMukTM/uEjNwUjLxYDM14SM2ATN)
}

// UpdateMessageDelayReqCard ...
type UpdateMessageDelayReqCard struct {
	Card    interface{} `json:"card,omitempty"`     // 消息卡片内容
	OpenIDs []string    `json:"open_ids,omitempty"` // 指定需要更新的用户，共享卡片默认更新所有人卡片，无需填写该字段
}

func (r UpdateMessageDelayReqCard) MarshalJSON() ([]byte, error) {
	bs, err := json.Marshal(r.Card)
	if err != nil {
		return nil, err
	}
	m := map[string]interface{}{}
	if err = json.Unmarshal(bs, &m); err != nil {
		return nil, err
	}
	m["open_ids"] = r.OpenIDs
	return json.Marshal(m)
}

// UpdateMessageDelayReqCardCard ...
type UpdateMessageDelayReqCardCard struct{}

// updateMessageDelayResp ...
type updateMessageDelayResp struct {
	Code int64                   `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 返回码描述
	Data *UpdateMessageDelayResp `json:"data,omitempty"`
}

// UpdateMessageDelayResp ...
type UpdateMessageDelayResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchGetOKR 根据OKR id批量获取OKR
//
// 使用tenant_access_token需要额外申请权限以应用身份访问OKR信息
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/okr-v1/okr/batch_get
func (r *OKRService) BatchGetOKR(ctx context.Context, request *BatchGetOKRReq, options ...MethodOptionFunc) (*BatchGetOKRResp, *Response, error) {
	if r.cli.mock.mockOKRBatchGetOKR != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] OKR#BatchGetOKR mock enable")
		return r.cli.mock.mockOKRBatchGetOKR(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "OKR",
		API:                   "BatchGetOKR",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/okr/v1/okrs/batch_get",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchGetOKRResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockOKRBatchGetOKR mock OKRBatchGetOKR method
func (r *Mock) MockOKRBatchGetOKR(f func(ctx context.Context, request *BatchGetOKRReq, options ...MethodOptionFunc) (*BatchGetOKRResp, *Response, error)) {
	r.mockOKRBatchGetOKR = f
}

// UnMockOKRBatchGetOKR un-mock OKRBatchGetOKR method
func (r *Mock) UnMockOKRBatchGetOKR() {
	r.mockOKRBatchGetOKR = nil
}

// BatchGetOKRReq ...
type BatchGetOKRReq struct {
	UserIDType *IDType  `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	OKRIDs     []string `query:"okr_ids" json:"-"`      // OKR ID 列表，最多10个
	Lang       *string  `query:"lang" json:"-"`         // 请求OKR的语言版本（比如@的人名），lang=en_us/zh_cn，请求 Query中, 示例值："zh_cn", 默认值: `zh_cn`
}

// batchGetOKRResp ...
type batchGetOKRResp struct {
	Code int64            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string           `json:"msg,omitempty"`  // 错误描述
	Data *BatchGetOKRResp `json:"data,omitempty"`
}

// BatchGetOKRResp ...
type BatchGetOKRResp struct {
	OKRList []*BatchGetOKRRespOKR `json:"okr_list,omitempty"` // OKR 列表
}

// BatchGetOKRRespOKR ...
type BatchGetOKRRespOKR struct {
	ID            string                         `json:"id,omitempty"`             // id
	Permission    int64                          `json:"permission,omitempty"`     // OKR的访问权限, 可选值有: `0`：此时OKR只返回id, `1`：返回OKR的其他具体字段
	Name          string                         `json:"name,omitempty"`           // 名称
	ObjectiveList []*BatchGetOKRRespOKRObjective `json:"objective_list,omitempty"` // Objective列表
}

// BatchGetOKRRespOKRObjective ...
type BatchGetOKRRespOKRObjective struct {
	ID                    string                                          `json:"id,omitempty"`                      // Objective ID
	Permission            int64                                           `json:"permission,omitempty"`              // 权限, 可选值有: `0`：此时OKR只返回id, `1`：返回OKR的其他具体字段
	Content               string                                          `json:"content,omitempty"`                 // Objective 内容
	ProgressReport        string                                          `json:"progress_report,omitempty"`         // Objective 进度记录内容
	Score                 int64                                           `json:"score,omitempty"`                   // Objective 分数（0 - 100）
	Weight                float64                                         `json:"weight,omitempty"`                  // Objective的权重（0 - 100）
	ProgressRate          *BatchGetOKRRespOKRObjectiveProgressRate        `json:"progress_rate,omitempty"`           // Objective进度
	KrList                []*BatchGetOKRRespOKRObjectiveKr                `json:"kr_list,omitempty"`                 // Objective KeyResult 列表
	AlignedObjectiveList  []*BatchGetOKRRespOKRObjectiveAlignedObjective  `json:"aligned_objective_list,omitempty"`  // 对齐到该Objective的Objective列表
	AligningObjectiveList []*BatchGetOKRRespOKRObjectiveAligningObjective `json:"aligning_objective_list,omitempty"` // 该Objective对齐到的Objective列表
}

// BatchGetOKRRespOKRObjectiveProgressRate ...
type BatchGetOKRRespOKRObjectiveProgressRate struct {
	Percent int64  `json:"percent,omitempty"` // Objective 进度百分比 >= 0
	Status  string `json:"status,omitempty"`  // Objective 进度状态, 可选值有: `-1`：未更新, `0`：正常, `1`：有风险, `2`：已延期
}

// BatchGetOKRRespOKRObjectiveKr ...
type BatchGetOKRRespOKRObjectiveKr struct {
	ID           string                                     `json:"id,omitempty"`            // Key Result ID
	Content      string                                     `json:"content,omitempty"`       // KeyResult 内容
	Score        int64                                      `json:"score,omitempty"`         // KeyResult打分（0 - 100）
	Weight       int64                                      `json:"weight,omitempty"`        // KeyResult权重（0 - 100）（废弃）
	KrWeight     float64                                    `json:"kr_weight,omitempty"`     // KeyResult的权重（0 - 100）
	ProgressRate *BatchGetOKRRespOKRObjectiveKrProgressRate `json:"progress_rate,omitempty"` // KR进度
}

// BatchGetOKRRespOKRObjectiveKrProgressRate ...
type BatchGetOKRRespOKRObjectiveKrProgressRate struct {
	Percent int64  `json:"percent,omitempty"` // Objective 进度百分比 >= 0
	Status  string `json:"status,omitempty"`  // Objective 进度状态, 可选值有: `-1`：未更新, `0`：正常, `1`：有风险, `2`：已延期
}

// BatchGetOKRRespOKRObjectiveAlignedObjective ...
type BatchGetOKRRespOKRObjectiveAlignedObjective struct {
	ID    string                                            `json:"id,omitempty"`     // Objective的ID
	OKRID string                                            `json:"okr_id,omitempty"` // OKR的ID
	Owner *BatchGetOKRRespOKRObjectiveAlignedObjectiveOwner `json:"owner,omitempty"`  // 该Objective的Owner
}

// BatchGetOKRRespOKRObjectiveAlignedObjectiveOwner ...
type BatchGetOKRRespOKRObjectiveAlignedObjectiveOwner struct {
	OpenID string `json:"open_id,omitempty"` // 用户的 open_id
}

// BatchGetOKRRespOKRObjectiveAligningObjective ...
type BatchGetOKRRespOKRObjectiveAligningObjective struct {
	ID    string                                             `json:"id,omitempty"`     // Objective的ID
	OKRID string                                             `json:"okr_id,omitempty"` // OKR的ID
	Owner *BatchGetOKRRespOKRObjectiveAligningObjectiveOwner `json:"owner,omitempty"`  // 该Objective的Owner
}

// BatchGetOKRRespOKRObjectiveAligningObjectiveOwner ...
type BatchGetOKRRespOKRObjectiveAligningObjectiveOwner struct {
	OpenID string `json:"open_id,omitempty"` // 用户的 open_id
}
