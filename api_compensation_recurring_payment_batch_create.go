// Code generated by lark_sdk_gen. DO NOT EDIT.
/**
 * Copyright 2022 chyroc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lark

import (
	"context"
)

// BatchCreateCompensationRecurringPayment 根据传入的参数, 校验并创建经常性支付记录, 返回创建失败的原因或创建成功的数据ID
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/compensation-v1/recurring_payment/batch_create
// new doc: https://open.feishu.cn/document/corehr-v1/basic-compensation/recurring_payment/batch_create
func (r *CompensationService) BatchCreateCompensationRecurringPayment(ctx context.Context, request *BatchCreateCompensationRecurringPaymentReq, options ...MethodOptionFunc) (*BatchCreateCompensationRecurringPaymentResp, *Response, error) {
	if r.cli.mock.mockCompensationBatchCreateCompensationRecurringPayment != nil {
		r.cli.Log(ctx, LogLevelDebug, "[lark] Compensation#BatchCreateCompensationRecurringPayment mock enable")
		return r.cli.mock.mockCompensationBatchCreateCompensationRecurringPayment(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Compensation",
		API:                   "BatchCreateCompensationRecurringPayment",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/compensation/v1/recurring_payment/batch_create",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(batchCreateCompensationRecurringPaymentResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCompensationBatchCreateCompensationRecurringPayment mock CompensationBatchCreateCompensationRecurringPayment method
func (r *Mock) MockCompensationBatchCreateCompensationRecurringPayment(f func(ctx context.Context, request *BatchCreateCompensationRecurringPaymentReq, options ...MethodOptionFunc) (*BatchCreateCompensationRecurringPaymentResp, *Response, error)) {
	r.mockCompensationBatchCreateCompensationRecurringPayment = f
}

// UnMockCompensationBatchCreateCompensationRecurringPayment un-mock CompensationBatchCreateCompensationRecurringPayment method
func (r *Mock) UnMockCompensationBatchCreateCompensationRecurringPayment() {
	r.mockCompensationBatchCreateCompensationRecurringPayment = nil
}

// BatchCreateCompensationRecurringPaymentReq ...
type BatchCreateCompensationRecurringPaymentReq struct {
	UserIDType IDType                                              `query:"user_id_type" json:"-"` // 用户 ID 类型示例值: open_id可选值有: 标识一个用户在某个应用中的身份。同一个用户在不同应用中的 Open ID 不同。[了解更多: 如何获取 Open ID](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-obtain-openid)标识一个用户在某个应用开发商下的身份。同一用户在同一开发商下的应用中的 Union ID 是相同的, 在不同开发商下的应用中的 Union ID 是不同的。通过 Union ID, 应用开发商可以把同个用户在多个应用中的身份关联起来。[了解更多: 如何获取 Union ID？](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-obtain-union-id)标识一个用户在某个租户内的身份。同一个用户在租户 A 和租户 B 内的 User ID 是不同的。在同一个租户内, 一个用户的 User ID 在所有应用（包括商店应用）中都保持一致。User ID 主要用于在不同的应用间打通用户数据。[了解更多: 如何获取 User ID？](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-obtain-user-id)以people_corehr_id来识别用户默认值: `open_id`当值为 `user_id`, 字段权限要求: 获取用户 user ID
	Records    []*BatchCreateCompensationRecurringPaymentReqRecord `json:"records,omitempty"`      // 要创建的经常性支付记录 长度范围: `0` ～ `500`
}

// BatchCreateCompensationRecurringPaymentReqRecord ...
type BatchCreateCompensationRecurringPaymentReqRecord struct {
	UniqueID                string  `json:"unique_id,omitempty"`                  // 经常性支付记录 unique_id, unique_id 在创建时由上游指定示例值: "7402510801304718380_7309316347007764012_7402523725868058156_1726070400000_10000" 长度范围: `0` ～ `255` 字符
	UserID                  string  `json:"user_id,omitempty"`                    // 员工id, 具体类型由入参中的 user_id_type 指定示例值: "7337149697626801708" 长度范围: `0` ～ `255` 字符
	ItemID                  string  `json:"item_id,omitempty"`                    // 薪酬项 id（通过[【查询薪酬项】](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/compensation-v1/item/list)) 接口进行查询）示例值: "7411039006180312620" 长度范围: `0` ～ `255` 字符
	EachAmount              string  `json:"each_amount,omitempty"`                // 每次发放金额示例值: "20.00" 长度范围: `0` ～ `255` 字符
	StartDate               string  `json:"start_date,omitempty"`                 // 发放开始时间示例值: "2024-08-01" 长度范围: `0` ～ `255` 字符
	EndDate                 string  `json:"end_date,omitempty"`                   // 发放结束时间示例值: "2025-08-01" 长度范围: `0` ～ `255` 字符
	CurrencyID              string  `json:"currency_id,omitempty"`                // 币种 id（通过[【查询币种】](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/corehr-v2/basic_info-currency/search)) 接口进行查询）示例值: "6863329932261459464" 长度范围: `0` ～ `255` 字符
	IssuanceType            string  `json:"issuance_type,omitempty"`              // 发放方式示例值: "with_salary"可选值有: 随工资发放现金发放实物发放随年终奖发放
	IssuancePeriod          string  `json:"issuance_period,omitempty"`            // 发放频率示例值: "year"可选值有: 年半年季度双月月双周周天小时
	Remark                  *string `json:"remark,omitempty"`                     // 备注示例值: "这是个备注" 长度范围: `0` ～ `3000` 字符
	IssuanceCountryRegionID *string `json:"issuance_country_region_id,omitempty"` // 发放国家id（可通过 https://open.larkoffice.com/document/uAjLw4CM/ukTMukTMukTM/corehr-v2/basic_info-country_region/search进行查询）示例值: "6862995745046267400" 长度范围: `0` ～ `255` 字符
}

// BatchCreateCompensationRecurringPaymentResp ...
type BatchCreateCompensationRecurringPaymentResp struct {
	OperateResults []*BatchCreateCompensationRecurringPaymentRespOperateResult `json:"operate_results,omitempty"` // 每条记录的操作结果。对于创建成功的记录, 会返回创建后的经常性支付记录id
}

// BatchCreateCompensationRecurringPaymentRespOperateResult ...
type BatchCreateCompensationRecurringPaymentRespOperateResult struct {
	ID       string `json:"id,omitempty"`        // 操作记录的id
	UniqueID string `json:"unique_id,omitempty"` // 操作的记录的 unique_id
	Code     int64  `json:"code,omitempty"`      // 操作结果状态码可选值有: "Success" 操作成功"The format of the single payment amount is incorrect" 单次发放金额格式不正确"The format of the distribution start time is incorrect" 发放开始时间格式不正确"The format of the issuance end time is incorrect" 发放结束时间格式不正确"No permission for recurring payment record" 没有该经常性支付记录权限"The recurring payment type salary item does not exist" 经常性支付类型薪酬项不存在"The currency does not exist" 币种不存在"The distribution method does not exist" 发放方式不存在"The distribution start time is greater than the distribution end time" 发放开始时间大于发放结束时间"Employees are not covered by the remuneration rules" 员工不在薪酬项规则适用范围之内"The payment method does not match the salary item rules" 发放方式不匹配薪酬项规则"Currency mismatch compensation item rules" 币种不匹配薪酬项规则"The distribution start date is earlier than the current date and cannot be deleted" 发放开始日期早于当前日期不可删除"The recurring payment record does not exist" 该经常性支付记录不存在"Payment frequency does not match the salary item" 发放频率不匹配薪酬项"The distribution start date and end date overlap" 发放开始日期和结束日期有重叠"Issuing country is empty" 发放国家为空"Issuing country does not exist" 发放国家不存在"The single payment amount cannot be 0" 单次发放金额不允许为0
	Message  string `json:"message,omitempty"`   // 操作结果描述
}

// batchCreateCompensationRecurringPaymentResp ...
type batchCreateCompensationRecurringPaymentResp struct {
	Code  int64                                        `json:"code,omitempty"` // 错误码, 非 0 表示失败
	Msg   string                                       `json:"msg,omitempty"`  // 错误描述
	Data  *BatchCreateCompensationRecurringPaymentResp `json:"data,omitempty"`
	Error *ErrorDetail                                 `json:"error,omitempty"`
}
