// Code generated by lark_sdk_gen. DO NOT EDIT.
/**
 * Copyright 2022 chyroc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lark

import (
	"context"
	"encoding/json"
)

// UpdateMessageDelay 用户点击卡片进行交互、你的服务端在收到并响应卡片的回调请求后, 可调用该接口延时更新卡片。
//
// ## 使用场景
// 本接口适用于以下场景:
// - 用户与卡片交互后, 无法在 3 秒内立即更新卡片。可调用本接口在 30 分钟内延时更新。
// - 用户与卡片交互后, 需要仅更新部分指定用户接收到的卡片。
// ## 延时更新消息卡片流程
// 调用本接口前, 你需参考下图, 了解整体更新流程:
// 1. 用户点击交互组件, 与卡片进行交互
// 2. 飞书服务器发送[卡片回传交互](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-callback-communication)回调
// 3. 你的服务器需要在接收回调的 3 秒内先以 HTTP 200 状态码响应该回调, 在响应时设置 HTTP Body 为 `"{}"` 或者返回自定义 Toast 结构体
// 5. 在[卡片回传交互](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-callback-communication)回调请求中获取 token 参数, 调用本接口, 在 30 分钟内更新卡片。
// :::warning
// 延时更新卡片必须在响应回调之后进行, 并行执行或提前执行会出现更新失败或更新后立即复原的情况。
// ![image.png](//sf3-cn.feishucdn.com/obj/open-platform-opendoc/39672c58aadbb0ea3e97d8b01401bcb1_8IVLvqd5H3.png?height=500&lazyload=true&maxWidth=600&width=1846)
// ## 使用限制
// - 延时更新所需的 token 有效期为 30 分钟, 超时则无法更新卡片, 且同一个 token 只能使用 2 次, 超过使用次数则无法更新卡片。
// - 只能更新当前应用机器人发送的、用户交互的卡片, 不允许更新其他卡片。
// - 卡片大小需控制在 30KB 以内。对于搭建工具搭建的卡片模板, 需确保模板中的 JSON 代码长度和变量长度之和控制在 30 KB 以内。如果卡片使用了循环容器, 循环容器的 JSON 长度 = 卡片模板中循环容器的 JSON 长度 × 循环的次数。
// ## 前提条件
// - 应用需要[启用机器人能力](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-enable-bot-ability)。
// - 你已参考[处理卡片回调-方式二: 延时更新卡片](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/handle-card-callbacks#8ba7bbc3), 在 3 秒内以 `HTTP 200` 状态码响应了卡片回传交互请求。
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uMDO1YjLzgTN24yM4UjN
// new doc: https://open.feishu.cn/document/server-docs/im-v1/message-card/delay-update-message-card
func (r *MessageService) UpdateMessageDelay(ctx context.Context, request *UpdateMessageDelayReq, options ...MethodOptionFunc) (*UpdateMessageDelayResp, *Response, error) {
	if r.cli.mock.mockMessageUpdateMessageDelay != nil {
		r.cli.Log(ctx, LogLevelDebug, "[lark] Message#UpdateMessageDelay mock enable")
		return r.cli.mock.mockMessageUpdateMessageDelay(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "UpdateMessageDelay",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/interactive/v1/card/update",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(updateMessageDelayResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageUpdateMessageDelay mock MessageUpdateMessageDelay method
func (r *Mock) MockMessageUpdateMessageDelay(f func(ctx context.Context, request *UpdateMessageDelayReq, options ...MethodOptionFunc) (*UpdateMessageDelayResp, *Response, error)) {
	r.mockMessageUpdateMessageDelay = f
}

// UnMockMessageUpdateMessageDelay un-mock MessageUpdateMessageDelay method
func (r *Mock) UnMockMessageUpdateMessageDelay() {
	r.mockMessageUpdateMessageDelay = nil
}

// UpdateMessageDelayReq ...
type UpdateMessageDelayReq struct {
	Token string                     `json:"token,omitempty"` // [卡片回传交互](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-callback-communication)回调中包含的 token 参数值。  示例值: "c-295ee57216a5dc9de90fefd0aadb4b1d7dxxxx"
	Card  *UpdateMessageDelayReqCard `json:"card,omitempty"`  // 消息卡片的内容, 可以是[卡片 JSON 数据](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-json-v2-structure), 也可以传入[卡片搭建工具](https://open.feishu.cn/cardkit?from=open_docs_overview)搭建的卡片相关信息。详情参考下方的请求体示例。
}

// UpdateMessageDelayReqCard ...
type UpdateMessageDelayReqCard struct {
	Card    interface{} `json:"card,omitempty"`     // 消息卡片的内容, 可以是[卡片 JSON 数据](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-json-v2-structure), 也可以传入[卡片搭建工具](https://open.feishu.cn/cardkit?from=open_docs_overview)搭建的卡片相关信息。详情参考下方的请求体示例。
	OpenIDs []string    `json:"open_ids,omitempty"` // 用户的 open_id 列表, 用于定义接收更新卡片的用户范围。获取方式参考[如何获取自己的 Open ID](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-obtain-openid)。  示例值: ["ou_5ad573a6411d72b8305fda3a9c15xxxx"]  注意: 该参数仅支持[卡片 JSON 1.0 结构](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-json-structure), 且仅在卡片的 `config.update_multi` 参数设置为` false`（即独享卡片）时可用。- 当卡片 `config.update_multi` 为 `false` 时, 该参数必填；若为 `true`（即共享卡片）, 请勿使用该参数, 否则可能导致卡片更新异常。
}

func (r UpdateMessageDelayReqCard) MarshalJSON() ([]byte, error) {
	bs, err := json.Marshal(r.Card)
	if err != nil {
		return nil, err
	}
	m := map[string]interface{}{}
	if err = json.Unmarshal(bs, &m); err != nil {
		return nil, err
	}
	m["open_ids"] = r.OpenIDs
	return json.Marshal(m)
}

// UpdateMessageDelayResp ...
type UpdateMessageDelayResp struct{}

// updateMessageDelayResp ...
type updateMessageDelayResp struct {
	Code  int64                   `json:"code,omitempty"` // 返回码, 非 0 表示失败
	Msg   string                  `json:"msg,omitempty"`  // 返回码描述
	Data  *UpdateMessageDelayResp `json:"data,omitempty"`
	Error *ErrorDetail            `json:"error,omitempty"`
}
