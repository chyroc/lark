// Code generated by lark_sdk_gen. DO NOT EDIT.
/**
 * Copyright 2022 chyroc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lark

import (
	"context"
)

// SendEphemeralMessage 调用该接口, 可以使应用机器人在指定群聊中发送仅指定用户可见的卡片消息。卡片上将展示 仅对你可见 标识, 如下图所示。
//
// ![image.png](//sf3-cn.feishucdn.com/obj/open-platform-opendoc/b0ec0ce45942463381457edc7b62e144_RXYCFtfUtb.png?height=486&lazyload=true&maxWidth=592&width=1592)
// ## 使用场景
// 仅特定人可见卡片一般作为临时的交互卡片使用, 交互过程仅该用户可见, 群内其他成员只会看到最终设置完成的提醒卡片, 可以减少消息对群聊中不相关用户的打扰, 有效降低群消息的噪声。
// 具体场景示例: 在群聊内, 管理员需要通过机器人推送的待办事项表单卡片, 设置提醒日期和提醒内容。设置完成后再将卡片推送给全部群成员。该过程中, 机器人可以先通过本接口推送仅群管理员可见的表单卡片, 待管理员与卡片完成交互后, 机器人再调用[删除仅特定人可见的消息卡片](https://open.feishu.cn/document/ukTMukTMukTM/uITOyYjLykjM24iM5IjN)接口, 删除该卡片消息, 并将完善后的待办事项卡片发送给全部群成员查看。
// ## 前提条件
// 调用该接口前, 请确保你的应用已启用[机器人能力](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-enable-bot-ability)且机器人在会话群里。
// ## 频率限制
// 对同一个群组发送仅特定人可见的消息卡片时, 该接口的调用频率上限是 40 QPS。
// ## 使用限制
// - 该接口不支持群模式为话题的话题群（topic）, 仅支持普通对话群组（group）。相关概念参考[群组基本概念](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/im-v1/chat/chat-info/intro)。
// - 该接口不支持[为卡片局部配置多语言](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/configure-multi-language-content#559f0561), 仅支持[为卡片全局配置多语言](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/configure-multi-language-content#ae4b3cb1)。
// - 通过本接口发送的卡片:
// - 不支持转发
// - 只能发送给群聊中的特定用户, 且该用户不会收到消息通知
// - 仅在处于在线状态的用户的飞书客户端上可见
// - 如果卡片中使用了@指定人语法, 被@的成员将不会收到提及通知
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uETOyYjLxkjM24SM5IjN
// new doc: https://open.feishu.cn/document/server-docs/im-v1/message-card/send-message-cards-that-are-only-visible-to-certain-people
func (r *MessageService) SendEphemeralMessage(ctx context.Context, request *SendEphemeralMessageReq, options ...MethodOptionFunc) (*SendEphemeralMessageResp, *Response, error) {
	if r.cli.mock.mockMessageSendEphemeralMessage != nil {
		r.cli.Log(ctx, LogLevelDebug, "[lark] Message#SendEphemeralMessage mock enable")
		return r.cli.mock.mockMessageSendEphemeralMessage(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Message",
		API:                   "SendEphemeralMessage",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/ephemeral/v1/send",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(sendEphemeralMessageResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockMessageSendEphemeralMessage mock MessageSendEphemeralMessage method
func (r *Mock) MockMessageSendEphemeralMessage(f func(ctx context.Context, request *SendEphemeralMessageReq, options ...MethodOptionFunc) (*SendEphemeralMessageResp, *Response, error)) {
	r.mockMessageSendEphemeralMessage = f
}

// UnMockMessageSendEphemeralMessage un-mock MessageSendEphemeralMessage method
func (r *Mock) UnMockMessageSendEphemeralMessage() {
	r.mockMessageSendEphemeralMessage = nil
}

// SendEphemeralMessageReq ...
type SendEphemeralMessageReq struct {
	ChatID  string              `json:"chat_id,omitempty"`  // 目标群 ID。仅支持群模式为对话的普通群, 不支持话题群。群 ID 获取方式参见[群 ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description)。  示例值: oc_5ad573a6411d72b8305fda3a9c1abcef
	OpenID  *string             `json:"open_id,omitempty"`  // 可见卡片的用户 open_id。ID 获取方式参考[如何获取 Open ID](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-obtain-openid)。注意: 你仅需填写 `open_id`、`email`、或 `user_id` 其中之一, 且三个字段不可同时为空。若填写多个, 字段生效的顺序为 `open_id` > `user_id` > `email`。 推荐使用 `open_id` 字段。  示例值: ou_449b53ad6aee526f7ed311b216aabcef
	UserID  *string             `json:"user_id,omitempty"`  // 可见卡片的用户 user_id。ID 获取方式参考[如何获取 User ID](https://open.feishu.cn/document/uAjLw4CM/ugTN1YjL4UTN24CO1UjN/trouble-shooting/how-to-obtain-user-id)。注意: 你仅需填写 `open_id`、`email`、或 `user_id` 其中之一, 且三个字段不可同时为空。若填写多个, 字段生效的顺序为 `open_id` > `user_id` > `email`。 推荐使用 `open_id` 字段。  示例值: gg895344
	Email   *string             `json:"email,omitempty"`    // 可见卡片的用户邮箱地址。注意: 你仅需填写 `open_id`、`email`、或 `user_id` 其中之一, 且三个字段不可同时为空。若填写多个, 字段生效的顺序为 `open_id` > `user_id` > `email`。 推荐使用 `open_id` 字段。  示例值: zhangmin@feishu.com
	MsgType MsgType             `json:"msg_type,omitempty"` // 消息的类型, 固定取值 `interactive`。  示例值: interactive
	Card    *MessageContentCard `json:"card,omitempty"`     // 消息卡片的内容。支持[卡片 JSON](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-json-v2-structure) 或[搭建工具](https://open.feishu.cn/cardkit?from=open_docs)构建的卡片模板。  - 要使用卡片 JSON, 参考[卡片 JSON 结构](https://open.feishu.cn/document/uAjLw4CM/ukzMukzMukzM/feishu-cards/card-json-v2-structure)。示例值可参考下文的请求体示例。  - 要使用[搭建工具](https://open.feishu.cn/cardkit?from=open_docs)构建的卡片模板, 你需传入 `type` 和 `data` 参数。详情参考下文示例。
}

// SendEphemeralMessageResp ...
type SendEphemeralMessageResp struct {
	MessageID string `json:"message_id,omitempty"` // 消息 ID
}

// sendEphemeralMessageResp ...
type sendEphemeralMessageResp struct {
	Code  int64                     `json:"code,omitempty"` // 返回码, 非 0 表示失败
	Msg   string                    `json:"msg,omitempty"`  // 返回码描述
	Data  *SendEphemeralMessageResp `json:"data,omitempty"`
	Error *ErrorDetail              `json:"error,omitempty"`
}
