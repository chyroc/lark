// Code generated by lark_sdk_gen. DO NOT EDIT.
/**
 * Copyright 2022 chyroc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package lark

import (
	"context"
)

// DeleteCalendarACL
//
// 该接口用于以当前身份（应用 / 用户）删除日历的控制权限，即日历成员。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份需要有日历的 owner 权限，并且日历的类型只能为 primary 或 shared。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/delete
func (r *CalendarService) DeleteCalendarACL(ctx context.Context, request *DeleteCalendarACLReq, options ...MethodOptionFunc) (*DeleteCalendarACLResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarACL != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarACL mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarACL(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarACL",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/acls/:acl_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarACLResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarDeleteCalendarACL mock CalendarDeleteCalendarACL method
func (r *Mock) MockCalendarDeleteCalendarACL(f func(ctx context.Context, request *DeleteCalendarACLReq, options ...MethodOptionFunc) (*DeleteCalendarACLResp, *Response, error)) {
	r.mockCalendarDeleteCalendarACL = f
}

// UnMockCalendarDeleteCalendarACL un-mock CalendarDeleteCalendarACL method
func (r *Mock) UnMockCalendarDeleteCalendarACL() {
	r.mockCalendarDeleteCalendarACL = nil
}

// DeleteCalendarACLReq ...
type DeleteCalendarACLReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	ACLID      string `path:"acl_id" json:"-"`      // acl资源ID。参见[ACL ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/introduction), 示例值："user_xxxxxx"
}

// deleteCalendarACLResp ...
type deleteCalendarACLResp struct {
	Code int64                  `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarACLResp `json:"data,omitempty"`
}

// DeleteCalendarACLResp ...
type DeleteCalendarACLResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarACLList
//
// 该接口用于以当前身份（应用 / 用户）获取日历的控制权限列表。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份需要有日历的 owner 权限，并且日历的类型只能为 primary 或 shared。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/list
func (r *CalendarService) GetCalendarACLList(ctx context.Context, request *GetCalendarACLListReq, options ...MethodOptionFunc) (*GetCalendarACLListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarACLList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarACLList mock enable")
		return r.cli.mock.mockCalendarGetCalendarACLList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarACLList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/acls",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarACLListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarACLList mock CalendarGetCalendarACLList method
func (r *Mock) MockCalendarGetCalendarACLList(f func(ctx context.Context, request *GetCalendarACLListReq, options ...MethodOptionFunc) (*GetCalendarACLListResp, *Response, error)) {
	r.mockCalendarGetCalendarACLList = f
}

// UnMockCalendarGetCalendarACLList un-mock CalendarGetCalendarACLList method
func (r *Mock) UnMockCalendarGetCalendarACLList() {
	r.mockCalendarGetCalendarACLList = nil
}

// GetCalendarACLListReq ...
type GetCalendarACLListReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageToken  *string `query:"page_token" json:"-"`   // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："xxx"
	PageSize   *int64  `query:"page_size" json:"-"`    // 分页大小, 示例值：10，小于10取10, 最大值：`50`
	CalendarID string  `path:"calendar_id" json:"-"`   // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// getCalendarACLListResp ...
type getCalendarACLListResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarACLListResp `json:"data,omitempty"`
}

// GetCalendarACLListResp ...
type GetCalendarACLListResp struct {
	Acls      []*GetCalendarACLListRespACL `json:"acls,omitempty"`       // 入参日历对应的acl列表
	HasMore   bool                         `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                       `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

// GetCalendarACLListRespACL ...
type GetCalendarACLListRespACL struct {
	ACLID string                          `json:"acl_id,omitempty"` // acl资源ID。参见[ACL ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/introduction)
	Role  CalendarRole                    `json:"role,omitempty"`   // 对日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
	Scope *GetCalendarACLListRespACLScope `json:"scope,omitempty"`  // 权限范围
}

// GetCalendarACLListRespACLScope ...
type GetCalendarACLListRespACLScope struct {
	Type   string `json:"type,omitempty"`    // 权限类型，当type为User时，值为open_id/user_id/union_id, 可选值有: `user`：用户
	UserID string `json:"user_id,omitempty"` // 用户ID，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendarACL 该接口用于以用户身份订阅指定日历下的日历成员变更事件。
//
// 用户必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-acl/subscription
func (r *CalendarService) SubscribeCalendarACL(ctx context.Context, request *SubscribeCalendarACLReq, options ...MethodOptionFunc) (*SubscribeCalendarACLResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendarACL != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendarACL mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendarACL(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SubscribeCalendarACL",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/acls/subscription",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(subscribeCalendarACLResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarSubscribeCalendarACL mock CalendarSubscribeCalendarACL method
func (r *Mock) MockCalendarSubscribeCalendarACL(f func(ctx context.Context, request *SubscribeCalendarACLReq, options ...MethodOptionFunc) (*SubscribeCalendarACLResp, *Response, error)) {
	r.mockCalendarSubscribeCalendarACL = f
}

// UnMockCalendarSubscribeCalendarACL un-mock CalendarSubscribeCalendarACL method
func (r *Mock) UnMockCalendarSubscribeCalendarACL() {
	r.mockCalendarSubscribeCalendarACL = nil
}

// SubscribeCalendarACLReq ...
type SubscribeCalendarACLReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// subscribeCalendarACLResp ...
type subscribeCalendarACLResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarACLResp `json:"data,omitempty"`
}

// SubscribeCalendarACLResp ...
type SubscribeCalendarACLResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendar
//
// 该接口用于为当前身份（应用 / 用户）创建一个共享日历。
// 身份由 Header Authorization 的 Token 类型决定。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/create
func (r *CalendarService) CreateCalendar(ctx context.Context, request *CreateCalendarReq, options ...MethodOptionFunc) (*CreateCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendar mock enable")
		return r.cli.mock.mockCalendarCreateCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarCreateCalendar mock CalendarCreateCalendar method
func (r *Mock) MockCalendarCreateCalendar(f func(ctx context.Context, request *CreateCalendarReq, options ...MethodOptionFunc) (*CreateCalendarResp, *Response, error)) {
	r.mockCalendarCreateCalendar = f
}

// UnMockCalendarCreateCalendar un-mock CalendarCreateCalendar method
func (r *Mock) UnMockCalendarCreateCalendar() {
	r.mockCalendarCreateCalendar = nil
}

// CreateCalendarReq ...
type CreateCalendarReq struct {
	Summary      *string             `json:"summary,omitempty"`       // 日历标题, 示例值："测试日历", 最大长度：`255` 字符
	Description  *string             `json:"description,omitempty"`   // 日历描述, 示例值："使用开放接口创建日历", 最大长度：`255` 字符
	Permissions  *CalendarPermission `json:"permissions,omitempty"`   // 日历公开范围, 示例值："private", 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        *int64              `json:"color,omitempty"`         // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效, 示例值：-1
	SummaryAlias *string             `json:"summary_alias,omitempty"` // 日历备注名，修改或添加后仅对当前身份生效, 示例值："日历备注名", 最大长度：`255` 字符
}

// createCalendarResp ...
type createCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarResp `json:"data,omitempty"`
}

// CreateCalendarResp ...
type CreateCalendarResp struct {
	Calendar *CreateCalendarRespCalendar `json:"calendar,omitempty"` // 新创建的日历实体
}

// CreateCalendarRespCalendar ...
type CreateCalendarRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendar
//
// 该接口用于以当前身份（应用 / 用户）删除一个共享日历。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历具有 owner 权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/delete
func (r *CalendarService) DeleteCalendar(ctx context.Context, request *DeleteCalendarReq, options ...MethodOptionFunc) (*DeleteCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendar mock enable")
		return r.cli.mock.mockCalendarDeleteCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendar",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarDeleteCalendar mock CalendarDeleteCalendar method
func (r *Mock) MockCalendarDeleteCalendar(f func(ctx context.Context, request *DeleteCalendarReq, options ...MethodOptionFunc) (*DeleteCalendarResp, *Response, error)) {
	r.mockCalendarDeleteCalendar = f
}

// UnMockCalendarDeleteCalendar un-mock CalendarDeleteCalendar method
func (r *Mock) UnMockCalendarDeleteCalendar() {
	r.mockCalendarDeleteCalendar = nil
}

// DeleteCalendarReq ...
type DeleteCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// deleteCalendarResp ...
type deleteCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarResp `json:"data,omitempty"`
}

// DeleteCalendarResp ...
type DeleteCalendarResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEventAttendeeChatMemberList 获取日程的群参与人的群成员列表。
//
// - 当前身份必须有权限查看日程的参与人列表。
// - 当前身份必须在群聊中，或有权限查看群成员列表。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee-chat_member/list
func (r *CalendarService) GetCalendarEventAttendeeChatMemberList(ctx context.Context, request *GetCalendarEventAttendeeChatMemberListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeChatMemberListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEventAttendeeChatMemberList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEventAttendeeChatMemberList mock enable")
		return r.cli.mock.mockCalendarGetCalendarEventAttendeeChatMemberList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEventAttendeeChatMemberList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees/:attendee_id/chat_members",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventAttendeeChatMemberListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarEventAttendeeChatMemberList mock CalendarGetCalendarEventAttendeeChatMemberList method
func (r *Mock) MockCalendarGetCalendarEventAttendeeChatMemberList(f func(ctx context.Context, request *GetCalendarEventAttendeeChatMemberListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeChatMemberListResp, *Response, error)) {
	r.mockCalendarGetCalendarEventAttendeeChatMemberList = f
}

// UnMockCalendarGetCalendarEventAttendeeChatMemberList un-mock CalendarGetCalendarEventAttendeeChatMemberList method
func (r *Mock) UnMockCalendarGetCalendarEventAttendeeChatMemberList() {
	r.mockCalendarGetCalendarEventAttendeeChatMemberList = nil
}

// GetCalendarEventAttendeeChatMemberListReq ...
type GetCalendarEventAttendeeChatMemberListReq struct {
	PageToken  *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："23jhysaxxxxsysy"
	PageSize   *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`100`
	CalendarID string  `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID    string  `path:"event_id" json:"-"`    // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："xxxxxxxxx_0"
	AttendeeID string  `path:"attendee_id" json:"-"` // 群参与人 ID。参见[参与人ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/introduction#4998889c), 示例值："chat_xxxxxx"
}

// getCalendarEventAttendeeChatMemberListResp ...
type getCalendarEventAttendeeChatMemberListResp struct {
	Code int64                                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                                      `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventAttendeeChatMemberListResp `json:"data,omitempty"`
}

// GetCalendarEventAttendeeChatMemberListResp ...
type GetCalendarEventAttendeeChatMemberListResp struct {
	Items     []*GetCalendarEventAttendeeChatMemberListRespItem `json:"items,omitempty"`      // 群中的群成员，当type为chat时有效；群成员不支持编辑
	HasMore   bool                                              `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                                            `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

// GetCalendarEventAttendeeChatMemberListRespItem ...
type GetCalendarEventAttendeeChatMemberListRespItem struct {
	RsvpStatus  string `json:"rsvp_status,omitempty"`  // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional  bool   `json:"is_optional,omitempty"`  // 参与人是否为「可选参加」
	DisplayName string `json:"display_name,omitempty"` // 参与人名称
	IsOrganizer bool   `json:"is_organizer,omitempty"` // 参与人是否为日程组织者
	IsExternal  bool   `json:"is_external,omitempty"`  // 参与人是否为外部参与人
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarEventAttendee 批量给日程添加参与人。
//
// - 当前身份需要有日历的 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// - 当前身份需要是日程的组织者，或日程设置了「参与人可邀请其它参与人」权限。
// - 新添加的日程参与人必须与日程组织者在同一个企业内。
// - 使用该接口添加会议室后，会议室会进入异步的预约流程，请求结束不代表会议室预约成功，需后续再查询预约状态。
// - 每个日程最多只能有 3000 名参与人。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/create
func (r *CalendarService) CreateCalendarEventAttendee(ctx context.Context, request *CreateCalendarEventAttendeeReq, options ...MethodOptionFunc) (*CreateCalendarEventAttendeeResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarEventAttendee != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarEventAttendee mock enable")
		return r.cli.mock.mockCalendarCreateCalendarEventAttendee(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendarEventAttendee",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createCalendarEventAttendeeResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarCreateCalendarEventAttendee mock CalendarCreateCalendarEventAttendee method
func (r *Mock) MockCalendarCreateCalendarEventAttendee(f func(ctx context.Context, request *CreateCalendarEventAttendeeReq, options ...MethodOptionFunc) (*CreateCalendarEventAttendeeResp, *Response, error)) {
	r.mockCalendarCreateCalendarEventAttendee = f
}

// UnMockCalendarCreateCalendarEventAttendee un-mock CalendarCreateCalendarEventAttendee method
func (r *Mock) UnMockCalendarCreateCalendarEventAttendee() {
	r.mockCalendarCreateCalendarEventAttendee = nil
}

// CreateCalendarEventAttendeeReq ...
type CreateCalendarEventAttendeeReq struct {
	UserIDType       *IDType                                   `query:"user_id_type" json:"-"`      // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	CalendarID       string                                    `path:"calendar_id" json:"-"`        // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string                                    `path:"event_id" json:"-"`           // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："xxxxxxxxx_0"
	Attendees        []*CreateCalendarEventAttendeeReqAttendee `json:"attendees,omitempty"`         // 新增参与人列表；<br>, 单次请求会议室的数量限制为100。
	NeedNotification *bool                                     `json:"need_notification,omitempty"` // 是否给参与人发送bot通知 默认为true, 示例值：false
}

// CreateCalendarEventAttendeeReqAttendee ...
type CreateCalendarEventAttendeeReqAttendee struct {
	Type                  *CalendarEventAttendeeType                                   `json:"type,omitempty"`                   // 参与人类型, 示例值："user", 可选值有: `user`：用户, `chat`：群组, `resource`：会议室, `third_party`：邮箱
	IsOptional            *bool                                                        `json:"is_optional,omitempty"`            // 参与人是否为「可选参加」，无法编辑群参与人的此字段, 示例值：true, 默认值: `false`
	UserID                *string                                                      `json:"user_id,omitempty"`                // 参与人的用户id，依赖于user_id_type返回对应的取值，当is_external为true时，此字段只会返回open_id或者union_id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 示例值："ou_xxxxxxxx"
	ChatID                *string                                                      `json:"chat_id,omitempty"`                // chat类型参与人的群组chat_id，参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description), 示例值："oc_xxxxxxxxx"
	RoomID                *string                                                      `json:"room_id,omitempty"`                // resource类型参与人的会议室room_id, 示例值："omm_xxxxxxxx"
	ThirdPartyEmail       *string                                                      `json:"third_party_email,omitempty"`      // third_party类型参与人的邮箱, 示例值："wangwu@email.com"
	OperateID             *string                                                      `json:"operate_id,omitempty"`             // 如果日程是使用应用身份创建的，在添加会议室的时候，用来指定会议室的联系人，在会议室视图展示。参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 示例值："ou_xxxxxxxx"
	ResourceCustomization *CreateCalendarEventAttendeeReqAttendeeResourceCustomization `json:"resource_customization,omitempty"` // 会议室的个性化配置
}

// CreateCalendarEventAttendeeReqAttendeeResourceCustomization ...
type CreateCalendarEventAttendeeReqAttendeeResourceCustomization struct {
	IndexKey     string                                                               `json:"index_key,omitempty"`     // 每个配置的唯一ID, 示例值："16281481596100"
	InputContent *string                                                              `json:"input_content,omitempty"` // 当type类型为填空时，该参数需要填入, 示例值："xxx"
	Options      []*CreateCalendarEventAttendeeReqAttendeeResourceCustomizationOption `json:"options,omitempty"`       // 每个配置的选项
}

// CreateCalendarEventAttendeeReqAttendeeResourceCustomizationOption ...
type CreateCalendarEventAttendeeReqAttendeeResourceCustomizationOption struct {
	OptionKey     *string `json:"option_key,omitempty"`     // 每个选项的唯一ID, 示例值："16281481596185"
	OthersContent *string `json:"others_content,omitempty"` // 当type类型为其它选项时，该参数需要填入, 示例值："xxx"
}

// createCalendarEventAttendeeResp ...
type createCalendarEventAttendeeResp struct {
	Code int64                            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarEventAttendeeResp `json:"data,omitempty"`
}

// CreateCalendarEventAttendeeResp ...
type CreateCalendarEventAttendeeResp struct {
	Attendees []*CreateCalendarEventAttendeeRespAttendee `json:"attendees,omitempty"` // 新增参与人后的日程所有参与人列表
}

// CreateCalendarEventAttendeeRespAttendee ...
type CreateCalendarEventAttendeeRespAttendee struct {
	Type                  CalendarEventAttendeeType                                     `json:"type,omitempty"`                   // 参与人类型, 可选值有: `user`：用户, `chat`：群组, `resource`：会议室, `third_party`：邮箱
	AttendeeID            string                                                        `json:"attendee_id,omitempty"`            // 参与人ID。参见[参与人ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/introduction#4998889c)
	RsvpStatus            string                                                        `json:"rsvp_status,omitempty"`            // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional            bool                                                          `json:"is_optional,omitempty"`            // 参与人是否为「可选参加」，无法编辑群参与人的此字段
	IsOrganizer           bool                                                          `json:"is_organizer,omitempty"`           // 参与人是否为日程组织者
	IsExternal            bool                                                          `json:"is_external,omitempty"`            // 参与人是否为外部参与人；外部参与人不支持编辑
	DisplayName           string                                                        `json:"display_name,omitempty"`           // 参与人名称
	ChatMembers           []*CreateCalendarEventAttendeeRespAttendeeChatMember          `json:"chat_members,omitempty"`           // 群中的群成员，当type为Chat时有效；群成员不支持编辑
	UserID                string                                                        `json:"user_id,omitempty"`                // 参与人的用户id，依赖于user_id_type返回对应的取值，当is_external为true时，此字段只会返回open_id或者union_id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	ChatID                string                                                        `json:"chat_id,omitempty"`                // chat类型参与人的群组chat_id，参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description)
	RoomID                string                                                        `json:"room_id,omitempty"`                // resource类型参与人的会议室room_id
	ThirdPartyEmail       string                                                        `json:"third_party_email,omitempty"`      // third_party类型参与人的邮箱
	OperateID             string                                                        `json:"operate_id,omitempty"`             // 如果日程是使用应用身份创建的，在添加会议室的时候，用来指定会议室的联系人，在会议室视图展示。参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	ResourceCustomization *CreateCalendarEventAttendeeRespAttendeeResourceCustomization `json:"resource_customization,omitempty"` // 会议室的个性化配置
}

// CreateCalendarEventAttendeeRespAttendeeChatMember ...
type CreateCalendarEventAttendeeRespAttendeeChatMember struct {
	RsvpStatus  string `json:"rsvp_status,omitempty"`  // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional  bool   `json:"is_optional,omitempty"`  // 参与人是否为「可选参加」
	DisplayName string `json:"display_name,omitempty"` // 参与人名称
	IsOrganizer bool   `json:"is_organizer,omitempty"` // 参与人是否为日程组织者
	IsExternal  bool   `json:"is_external,omitempty"`  // 参与人是否为外部参与人
}

// CreateCalendarEventAttendeeRespAttendeeResourceCustomization ...
type CreateCalendarEventAttendeeRespAttendeeResourceCustomization struct {
	IndexKey     string                                                                `json:"index_key,omitempty"`     // 每个配置的唯一ID
	InputContent string                                                                `json:"input_content,omitempty"` // 当type类型为填空时，该参数需要填入
	Options      []*CreateCalendarEventAttendeeRespAttendeeResourceCustomizationOption `json:"options,omitempty"`       // 每个配置的选项
}

// CreateCalendarEventAttendeeRespAttendeeResourceCustomizationOption ...
type CreateCalendarEventAttendeeRespAttendeeResourceCustomizationOption struct {
	OptionKey     string `json:"option_key,omitempty"`     // 每个选项的唯一ID
	OthersContent string `json:"others_content,omitempty"` // 当type类型为其它选项时，该参数需要填入
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarEventAttendee 批量删除日程的参与人。
//
// - 当前身份需要有日历的 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// - 当前身份需要是日程的组织者。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/batch_delete
func (r *CalendarService) DeleteCalendarEventAttendee(ctx context.Context, request *DeleteCalendarEventAttendeeReq, options ...MethodOptionFunc) (*DeleteCalendarEventAttendeeResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarEventAttendee != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarEventAttendee mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarEventAttendee(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarEventAttendee",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees/batch_delete",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarEventAttendeeResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarDeleteCalendarEventAttendee mock CalendarDeleteCalendarEventAttendee method
func (r *Mock) MockCalendarDeleteCalendarEventAttendee(f func(ctx context.Context, request *DeleteCalendarEventAttendeeReq, options ...MethodOptionFunc) (*DeleteCalendarEventAttendeeResp, *Response, error)) {
	r.mockCalendarDeleteCalendarEventAttendee = f
}

// UnMockCalendarDeleteCalendarEventAttendee un-mock CalendarDeleteCalendarEventAttendee method
func (r *Mock) UnMockCalendarDeleteCalendarEventAttendee() {
	r.mockCalendarDeleteCalendarEventAttendee = nil
}

// DeleteCalendarEventAttendeeReq ...
type DeleteCalendarEventAttendeeReq struct {
	CalendarID       string   `path:"calendar_id" json:"-"`        // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string   `path:"event_id" json:"-"`           // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："xxxxxxxxx_0"
	AttendeeIDs      []string `json:"attendee_ids,omitempty"`      // 要移除的参与人 ID 列表。参见[参与人ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/introduction#4998889c), 示例值：["user_xxxxx", "chat_xxxxx", "resource_xxxxx", "third_party_xxxxx"]
	NeedNotification *bool    `json:"need_notification,omitempty"` // 删除日程参与人时是否要给参与人发送bot通知，默认为true, 示例值：false
}

// deleteCalendarEventAttendeeResp ...
type deleteCalendarEventAttendeeResp struct {
	Code int64                            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                           `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarEventAttendeeResp `json:"data,omitempty"`
}

// DeleteCalendarEventAttendeeResp ...
type DeleteCalendarEventAttendeeResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEventAttendeeList 获取日程的参与人列表，若参与者列表中有群组，请使用 [获取参与人群成员列表](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee-chat_member/list) 。
//
// - 当前身份必须对日历有reader、writer或owner权限（调用[获取日历](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get)接口，role字段可查看权限）。
// - 当前身份必须有权限查看日程的参与人列表。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/list
func (r *CalendarService) GetCalendarEventAttendeeList(ctx context.Context, request *GetCalendarEventAttendeeListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEventAttendeeList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEventAttendeeList mock enable")
		return r.cli.mock.mockCalendarGetCalendarEventAttendeeList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEventAttendeeList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id/attendees",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventAttendeeListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarEventAttendeeList mock CalendarGetCalendarEventAttendeeList method
func (r *Mock) MockCalendarGetCalendarEventAttendeeList(f func(ctx context.Context, request *GetCalendarEventAttendeeListReq, options ...MethodOptionFunc) (*GetCalendarEventAttendeeListResp, *Response, error)) {
	r.mockCalendarGetCalendarEventAttendeeList = f
}

// UnMockCalendarGetCalendarEventAttendeeList un-mock CalendarGetCalendarEventAttendeeList method
func (r *Mock) UnMockCalendarGetCalendarEventAttendeeList() {
	r.mockCalendarGetCalendarEventAttendeeList = nil
}

// GetCalendarEventAttendeeListReq ...
type GetCalendarEventAttendeeListReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageToken  *string `query:"page_token" json:"-"`   // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："780TRhwXXXXX"
	PageSize   *int64  `query:"page_size" json:"-"`    // 分页大小, 示例值：10, 最大值：`100`
	CalendarID string  `path:"calendar_id" json:"-"`   // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID    string  `path:"event_id" json:"-"`      // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："xxxxxxxxx_0"
}

// getCalendarEventAttendeeListResp ...
type getCalendarEventAttendeeListResp struct {
	Code int64                             `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                            `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventAttendeeListResp `json:"data,omitempty"`
}

// GetCalendarEventAttendeeListResp ...
type GetCalendarEventAttendeeListResp struct {
	Items     []*GetCalendarEventAttendeeListRespItem `json:"items,omitempty"`      // 日程的参与者列表
	HasMore   bool                                    `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                                  `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

// GetCalendarEventAttendeeListRespItem ...
type GetCalendarEventAttendeeListRespItem struct {
	Type                  CalendarEventAttendeeType                                  `json:"type,omitempty"`                   // 参与人类型, 可选值有: `user`：用户, `chat`：群组, `resource`：会议室, `third_party`：邮箱
	AttendeeID            string                                                     `json:"attendee_id,omitempty"`            // 参与人ID。参见[参与人ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event-attendee/introduction#4998889c)
	RsvpStatus            string                                                     `json:"rsvp_status,omitempty"`            // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional            bool                                                       `json:"is_optional,omitempty"`            // 参与人是否为「可选参加」，无法编辑群参与人的此字段
	IsOrganizer           bool                                                       `json:"is_organizer,omitempty"`           // 参与人是否为日程组织者
	IsExternal            bool                                                       `json:"is_external,omitempty"`            // 参与人是否为外部参与人；外部参与人不支持编辑
	DisplayName           string                                                     `json:"display_name,omitempty"`           // 参与人名称
	ChatMembers           []*GetCalendarEventAttendeeListRespItemChatMember          `json:"chat_members,omitempty"`           // 群中的群成员，当type为Chat时有效；群成员不支持编辑
	UserID                string                                                     `json:"user_id,omitempty"`                // 参与人的用户id，依赖于user_id_type返回对应的取值，当is_external为true时，此字段只会返回open_id或者union_id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	ChatID                string                                                     `json:"chat_id,omitempty"`                // chat类型参与人的群组chat_id，参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description)
	RoomID                string                                                     `json:"room_id,omitempty"`                // resource类型参与人的会议室room_id
	ThirdPartyEmail       string                                                     `json:"third_party_email,omitempty"`      // third_party类型参与人的邮箱
	OperateID             string                                                     `json:"operate_id,omitempty"`             // 如果日程是使用应用身份创建的，在添加会议室的时候，用来指定会议室的联系人，在会议室视图展示。参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	ResourceCustomization *GetCalendarEventAttendeeListRespItemResourceCustomization `json:"resource_customization,omitempty"` // 会议室的个性化配置
}

// GetCalendarEventAttendeeListRespItemChatMember ...
type GetCalendarEventAttendeeListRespItemChatMember struct {
	RsvpStatus  string `json:"rsvp_status,omitempty"`  // 参与人RSVP状态, 可选值有: `needs_action`：参与人尚未回复状态，或表示会议室预约中, `accept`：参与人回复接受，或表示会议室预约成功, `tentative`：参与人回复待定, `decline`：参与人回复拒绝，或表示会议室预约失败, `removed`：参与人或会议室已经从日程中被移除
	IsOptional  bool   `json:"is_optional,omitempty"`  // 参与人是否为「可选参加」
	DisplayName string `json:"display_name,omitempty"` // 参与人名称
	IsOrganizer bool   `json:"is_organizer,omitempty"` // 参与人是否为日程组织者
	IsExternal  bool   `json:"is_external,omitempty"`  // 参与人是否为外部参与人
}

// GetCalendarEventAttendeeListRespItemResourceCustomization ...
type GetCalendarEventAttendeeListRespItemResourceCustomization struct {
	IndexKey     string                                                             `json:"index_key,omitempty"`     // 每个配置的唯一ID
	InputContent string                                                             `json:"input_content,omitempty"` // 当type类型为填空时，该参数需要填入
	Options      []*GetCalendarEventAttendeeListRespItemResourceCustomizationOption `json:"options,omitempty"`       // 每个配置的选项
}

// GetCalendarEventAttendeeListRespItemResourceCustomizationOption ...
type GetCalendarEventAttendeeListRespItemResourceCustomizationOption struct {
	OptionKey     string `json:"option_key,omitempty"`     // 每个选项的唯一ID
	OthersContent string `json:"others_content,omitempty"` // 当type类型为其它选项时，该参数需要填入
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarEvent
//
// 该接口用于以当前身份（应用 / 用户）在日历上创建一个日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/create
func (r *CalendarService) CreateCalendarEvent(ctx context.Context, request *CreateCalendarEventReq, options ...MethodOptionFunc) (*CreateCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarEvent mock enable")
		return r.cli.mock.mockCalendarCreateCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendarEvent",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarCreateCalendarEvent mock CalendarCreateCalendarEvent method
func (r *Mock) MockCalendarCreateCalendarEvent(f func(ctx context.Context, request *CreateCalendarEventReq, options ...MethodOptionFunc) (*CreateCalendarEventResp, *Response, error)) {
	r.mockCalendarCreateCalendarEvent = f
}

// UnMockCalendarCreateCalendarEvent un-mock CalendarCreateCalendarEvent method
func (r *Mock) UnMockCalendarCreateCalendarEvent() {
	r.mockCalendarCreateCalendarEvent = nil
}

// CreateCalendarEventReq ...
type CreateCalendarEventReq struct {
	CalendarID       string                            `path:"calendar_id" json:"-"`        // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	Summary          *string                           `json:"summary,omitempty"`           // 日程标题, 示例值："日程标题", 最大长度：`1000` 字符
	Description      *string                           `json:"description,omitempty"`       // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失, 示例值："日程描述", 最大长度：`40960` 字符
	NeedNotification *bool                             `json:"need_notification,omitempty"` // 更新日程是否给日程参与人发送bot通知，默认为true, 示例值：false
	StartTime        *CreateCalendarEventReqStartTime  `json:"start_time,omitempty"`        // 日程开始时间
	EndTime          *CreateCalendarEventReqEndTime    `json:"end_time,omitempty"`          // 日程结束时间
	Vchat            *CreateCalendarEventReqVchat      `json:"vchat,omitempty"`             // 视频会议信息。
	Visibility       *string                           `json:"visibility,omitempty"`        // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："default", 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  *string                           `json:"attendee_ability,omitempty"`  // 参与人权限, 示例值："can_see_others", 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   *string                           `json:"free_busy_status,omitempty"`  // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："busy", 可选值有: `busy`：忙碌, `free`：空闲
	Location         *CreateCalendarEventReqLocation   `json:"location,omitempty"`          // 日程地点
	Color            *int64                            `json:"color,omitempty"`             // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。, 示例值：-1
	Reminders        []*CreateCalendarEventReqReminder `json:"reminders,omitempty"`         // 日程提醒列表
	Recurrence       *string                           `json:"recurrence,omitempty"`        // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 示例值："FREQ=DAILY;INTERVAL=1", 最大长度：`2000` 字符
	Schemas          []*CreateCalendarEventReqSchema   `json:"schemas,omitempty"`           // 日程自定义信息；控制日程详情页的ui展示。
}

// CreateCalendarEventReqStartTime ...
type CreateCalendarEventReqStartTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1602504000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

// CreateCalendarEventReqEndTime ...
type CreateCalendarEventReqEndTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1602504000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

// CreateCalendarEventReqVchat ...
type CreateCalendarEventReqVchat struct {
	VCType      *string `json:"vc_type,omitempty"`     // 视频会议类型, 示例值："third_party", 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    *string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 示例值："vc", 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description *string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 示例值："发起视频会议", 长度范围：`0` ～ `500` 字符
	MeetingURL  *string `json:"meeting_url,omitempty"` // 视频会议URL, 示例值："https://example.com", 长度范围：`1` ～ `2000` 字符
}

// CreateCalendarEventReqLocation ...
type CreateCalendarEventReqLocation struct {
	Name      *string  `json:"name,omitempty"`      // 地点名称, 示例值："地点名称", 长度范围：`1` ～ `512` 字符
	Address   *string  `json:"address,omitempty"`   // 地点地址, 示例值："地点地址", 长度范围：`1` ～ `255` 字符
	Latitude  *float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：1.100000023841858
	Longitude *float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：2.200000047683716
}

// CreateCalendarEventReqReminder ...
type CreateCalendarEventReqReminder struct {
	Minutes *int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 示例值：5, 取值范围：`-20160` ～ `20160`
}

// CreateCalendarEventReqSchema ...
type CreateCalendarEventReqSchema struct {
	UiName   *string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域, 示例值："ForwardIcon"
	UiStatus *string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 示例值："hide", 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  *string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**, 示例值："https://applink.feishu.cn/client/calendar/event/detail?calendarId=xxxxxx&key=xxxxxx&originalTime=xxxxxx&startTime=xxxxxx", 最大长度：`2000` 字符
}

// createCalendarEventResp ...
type createCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarEventResp `json:"data,omitempty"`
}

// CreateCalendarEventResp ...
type CreateCalendarEventResp struct {
	Event *CreateCalendarEventRespEvent `json:"event,omitempty"` // 新创建的日程实体
}

// CreateCalendarEventRespEvent ...
type CreateCalendarEventRespEvent struct {
	EventID             string                                  `json:"event_id,omitempty"`              // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction)
	OrganizerCalendarID string                                  `json:"organizer_calendar_id,omitempty"` // 日程组织者日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary             string                                  `json:"summary,omitempty"`               // 日程标题
	Description         string                                  `json:"description,omitempty"`           // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失
	NeedNotification    bool                                    `json:"need_notification,omitempty"`     // 更新日程是否给日程参与人发送bot通知，默认为true
	StartTime           *CreateCalendarEventRespEventStartTime  `json:"start_time,omitempty"`            // 日程开始时间
	EndTime             *CreateCalendarEventRespEventEndTime    `json:"end_time,omitempty"`              // 日程结束时间
	Vchat               *CreateCalendarEventRespEventVchat      `json:"vchat,omitempty"`                 // 视频会议信息。
	Visibility          string                                  `json:"visibility,omitempty"`            // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility     string                                  `json:"attendee_ability,omitempty"`      // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus      string                                  `json:"free_busy_status,omitempty"`      // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location            *CreateCalendarEventRespEventLocation   `json:"location,omitempty"`              // 日程地点
	Color               int64                                   `json:"color,omitempty"`                 // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders           []*CreateCalendarEventRespEventReminder `json:"reminders,omitempty"`             // 日程提醒列表
	Recurrence          string                                  `json:"recurrence,omitempty"`            // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status              string                                  `json:"status,omitempty"`                // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException         bool                                    `json:"is_exception,omitempty"`          // 日程是否是一个重复日程的例外日程
	RecurringEventID    string                                  `json:"recurring_event_id,omitempty"`    // 例外日程的原重复日程的event_id
	Schemas             []*CreateCalendarEventRespEventSchema   `json:"schemas,omitempty"`               // 日程自定义信息；控制日程详情页的ui展示。
}

// CreateCalendarEventRespEventStartTime ...
type CreateCalendarEventRespEventStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// CreateCalendarEventRespEventEndTime ...
type CreateCalendarEventRespEventEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// CreateCalendarEventRespEventVchat ...
type CreateCalendarEventRespEventVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

// CreateCalendarEventRespEventLocation ...
type CreateCalendarEventRespEventLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

// CreateCalendarEventRespEventReminder ...
type CreateCalendarEventRespEventReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

// CreateCalendarEventRespEventSchema ...
type CreateCalendarEventRespEventSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarEvent
//
// 该接口用于以当前身份（应用 / 用户）删除日历上的一个日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// 当前身份必须是日程的组织者。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/delete
func (r *CalendarService) DeleteCalendarEvent(ctx context.Context, request *DeleteCalendarEventReq, options ...MethodOptionFunc) (*DeleteCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarEvent mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarEvent",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarDeleteCalendarEvent mock CalendarDeleteCalendarEvent method
func (r *Mock) MockCalendarDeleteCalendarEvent(f func(ctx context.Context, request *DeleteCalendarEventReq, options ...MethodOptionFunc) (*DeleteCalendarEventResp, *Response, error)) {
	r.mockCalendarDeleteCalendarEvent = f
}

// UnMockCalendarDeleteCalendarEvent un-mock CalendarDeleteCalendarEvent method
func (r *Mock) UnMockCalendarDeleteCalendarEvent() {
	r.mockCalendarDeleteCalendarEvent = nil
}

// DeleteCalendarEventReq ...
type DeleteCalendarEventReq struct {
	NeedNotification *bool  `query:"need_notification" json:"-"` // 删除日程是否给日程参与人发送bot通知，默认为true, 示例值：false, 可选值有: `true`：true, `false`：false
	CalendarID       string `path:"calendar_id" json:"-"`        // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string `path:"event_id" json:"-"`           // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："xxxxxxxxx_0"
}

// deleteCalendarEventResp ...
type deleteCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarEventResp `json:"data,omitempty"`
}

// DeleteCalendarEventResp ...
type DeleteCalendarEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEvent 该接口用于以当前身份（应用 / 用户）获取日历上的一个日程。
//
// 当前身份必须对日历有reader、writer或owner权限才会返回日程详细信息（调用[获取日历](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get)接口，role字段可查看权限）。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/get
func (r *CalendarService) GetCalendarEvent(ctx context.Context, request *GetCalendarEventReq, options ...MethodOptionFunc) (*GetCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEvent mock enable")
		return r.cli.mock.mockCalendarGetCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEvent",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarEvent mock CalendarGetCalendarEvent method
func (r *Mock) MockCalendarGetCalendarEvent(f func(ctx context.Context, request *GetCalendarEventReq, options ...MethodOptionFunc) (*GetCalendarEventResp, *Response, error)) {
	r.mockCalendarGetCalendarEvent = f
}

// UnMockCalendarGetCalendarEvent un-mock CalendarGetCalendarEvent method
func (r *Mock) UnMockCalendarGetCalendarEvent() {
	r.mockCalendarGetCalendarEvent = nil
}

// GetCalendarEventReq ...
type GetCalendarEventReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID    string `path:"event_id" json:"-"`    // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："xxxxxxxxx_0"
}

// getCalendarEventResp ...
type getCalendarEventResp struct {
	Code int64                 `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventResp `json:"data,omitempty"`
}

// GetCalendarEventResp ...
type GetCalendarEventResp struct {
	Event *GetCalendarEventRespEvent `json:"event,omitempty"` // 日程实体
}

// GetCalendarEventRespEvent ...
type GetCalendarEventRespEvent struct {
	EventID             string                               `json:"event_id,omitempty"`              // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction)
	OrganizerCalendarID string                               `json:"organizer_calendar_id,omitempty"` // 日程组织者日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary             string                               `json:"summary,omitempty"`               // 日程标题
	Description         string                               `json:"description,omitempty"`           // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失
	StartTime           *GetCalendarEventRespEventStartTime  `json:"start_time,omitempty"`            // 日程开始时间
	EndTime             *GetCalendarEventRespEventEndTime    `json:"end_time,omitempty"`              // 日程结束时间
	Vchat               *GetCalendarEventRespEventVchat      `json:"vchat,omitempty"`                 // 视频会议信息。
	Visibility          string                               `json:"visibility,omitempty"`            // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility     string                               `json:"attendee_ability,omitempty"`      // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus      string                               `json:"free_busy_status,omitempty"`      // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location            *GetCalendarEventRespEventLocation   `json:"location,omitempty"`              // 日程地点
	Color               int64                                `json:"color,omitempty"`                 // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders           []*GetCalendarEventRespEventReminder `json:"reminders,omitempty"`             // 日程提醒列表
	Recurrence          string                               `json:"recurrence,omitempty"`            // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status              string                               `json:"status,omitempty"`                // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException         bool                                 `json:"is_exception,omitempty"`          // 日程是否是一个重复日程的例外日程
	RecurringEventID    string                               `json:"recurring_event_id,omitempty"`    // 例外日程的原重复日程的event_id
	Schemas             []*GetCalendarEventRespEventSchema   `json:"schemas,omitempty"`               // 日程自定义信息；控制日程详情页的ui展示。
}

// GetCalendarEventRespEventStartTime ...
type GetCalendarEventRespEventStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// GetCalendarEventRespEventEndTime ...
type GetCalendarEventRespEventEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// GetCalendarEventRespEventVchat ...
type GetCalendarEventRespEventVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

// GetCalendarEventRespEventLocation ...
type GetCalendarEventRespEventLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

// GetCalendarEventRespEventReminder ...
type GetCalendarEventRespEventReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

// GetCalendarEventRespEventSchema ...
type GetCalendarEventRespEventSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarEventList 该接口用于以当前身份（应用 / 用户）获取日历下的日程列表。
//
// - 当前身份必须对日历有reader、writer或owner权限才会返回日程详细信息（调用[获取日历](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get)接口，role字段可查看权限）。
// - 仅支持primary、shared和resource类型的日历获取日程列表。
// - 调用时首先使用 page_token 分页拉取存量数据，之后使用 sync_token 增量同步变更数据。
// - 为了确保调用方日程同步数据的一致性，在使用sync_token时，不能同时使用start_time和end_time，否则可能造成日程数据缺失。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/list
func (r *CalendarService) GetCalendarEventList(ctx context.Context, request *GetCalendarEventListReq, options ...MethodOptionFunc) (*GetCalendarEventListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarEventList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarEventList mock enable")
		return r.cli.mock.mockCalendarGetCalendarEventList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarEventList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarEventListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarEventList mock CalendarGetCalendarEventList method
func (r *Mock) MockCalendarGetCalendarEventList(f func(ctx context.Context, request *GetCalendarEventListReq, options ...MethodOptionFunc) (*GetCalendarEventListResp, *Response, error)) {
	r.mockCalendarGetCalendarEventList = f
}

// UnMockCalendarGetCalendarEventList un-mock CalendarGetCalendarEventList method
func (r *Mock) UnMockCalendarGetCalendarEventList() {
	r.mockCalendarGetCalendarEventList = nil
}

// GetCalendarEventListReq ...
type GetCalendarEventListReq struct {
	PageSize   *int64  `query:"page_size" json:"-"`   // 一次请求要求返回最大数量，默认500，取值范围为[50, 1000], 示例值：50, 默认值: `500`, 取值范围：`50` ～ `1000`
	AnchorTime *string `query:"anchor_time" json:"-"` // 拉取anchor_time之后的日程，为timestamp, 示例值："1609430400"
	PageToken  *string `query:"page_token" json:"-"`  // 上次请求Response返回的分页标记，首次请求时为空, 示例值："ListCalendarsPageToken_1632452910_1632539310"
	SyncToken  *string `query:"sync_token" json:"-"`  // 上次请求Response返回的增量同步标记，分页请求未结束时为空, 示例值："ListCalendarsSyncToken_1632452910"
	StartTime  *string `query:"start_time" json:"-"`  // 日程开始Unix时间戳，单位为秒, 示例值："1631777271"
	EndTime    *string `query:"end_time" json:"-"`    // 日程结束Unix时间戳，单位为秒, 示例值："1631777271"
	CalendarID string  `path:"calendar_id" json:"-"`  // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// getCalendarEventListResp ...
type getCalendarEventListResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarEventListResp `json:"data,omitempty"`
}

// GetCalendarEventListResp ...
type GetCalendarEventListResp struct {
	HasMore   bool                            `json:"has_more,omitempty"`   // 是否有下一页数据
	PageToken string                          `json:"page_token,omitempty"` // 下次请求需要带上的分页标记，90 天有效期
	SyncToken string                          `json:"sync_token,omitempty"` // 下次请求需要带上的增量同步标记，90 天有效期
	Items     []*GetCalendarEventListRespItem `json:"items,omitempty"`      // 日程列表
}

// GetCalendarEventListRespItem ...
type GetCalendarEventListRespItem struct {
	EventID             string                                  `json:"event_id,omitempty"`              // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction)
	OrganizerCalendarID string                                  `json:"organizer_calendar_id,omitempty"` // 日程组织者日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary             string                                  `json:"summary,omitempty"`               // 日程标题
	Description         string                                  `json:"description,omitempty"`           // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失
	StartTime           *GetCalendarEventListRespItemStartTime  `json:"start_time,omitempty"`            // 日程开始时间
	EndTime             *GetCalendarEventListRespItemEndTime    `json:"end_time,omitempty"`              // 日程结束时间
	Vchat               *GetCalendarEventListRespItemVchat      `json:"vchat,omitempty"`                 // 视频会议信息。
	Visibility          string                                  `json:"visibility,omitempty"`            // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility     string                                  `json:"attendee_ability,omitempty"`      // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus      string                                  `json:"free_busy_status,omitempty"`      // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location            *GetCalendarEventListRespItemLocation   `json:"location,omitempty"`              // 日程地点
	Color               int64                                   `json:"color,omitempty"`                 // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders           []*GetCalendarEventListRespItemReminder `json:"reminders,omitempty"`             // 日程提醒列表
	Recurrence          string                                  `json:"recurrence,omitempty"`            // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status              string                                  `json:"status,omitempty"`                // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException         bool                                    `json:"is_exception,omitempty"`          // 日程是否是一个重复日程的例外日程
	RecurringEventID    string                                  `json:"recurring_event_id,omitempty"`    // 例外日程的原重复日程的event_id
	Schemas             []*GetCalendarEventListRespItemSchema   `json:"schemas,omitempty"`               // 日程自定义信息；控制日程详情页的ui展示。
}

// GetCalendarEventListRespItemStartTime ...
type GetCalendarEventListRespItemStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// GetCalendarEventListRespItemEndTime ...
type GetCalendarEventListRespItemEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// GetCalendarEventListRespItemVchat ...
type GetCalendarEventListRespItemVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

// GetCalendarEventListRespItemLocation ...
type GetCalendarEventListRespItemLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

// GetCalendarEventListRespItemReminder ...
type GetCalendarEventListRespItemReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

// GetCalendarEventListRespItemSchema ...
type GetCalendarEventListRespItemSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateCalendarEvent
//
// 该接口用于以当前身份（应用 / 用户）更新日历上的一个日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有 writer 或 owner 权限，并且日历的类型只能为 primary 或 shared。
// 当前身份为日程组织者时，可修改所有可编辑字段。
// 当前身份为日程参与者时，仅可编辑部分字段。（如：visibility, free_busy_status, color, reminders）
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/patch
func (r *CalendarService) UpdateCalendarEvent(ctx context.Context, request *UpdateCalendarEventReq, options ...MethodOptionFunc) (*UpdateCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarUpdateCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#UpdateCalendarEvent mock enable")
		return r.cli.mock.mockCalendarUpdateCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "UpdateCalendarEvent",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/:event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarUpdateCalendarEvent mock CalendarUpdateCalendarEvent method
func (r *Mock) MockCalendarUpdateCalendarEvent(f func(ctx context.Context, request *UpdateCalendarEventReq, options ...MethodOptionFunc) (*UpdateCalendarEventResp, *Response, error)) {
	r.mockCalendarUpdateCalendarEvent = f
}

// UnMockCalendarUpdateCalendarEvent un-mock CalendarUpdateCalendarEvent method
func (r *Mock) UnMockCalendarUpdateCalendarEvent() {
	r.mockCalendarUpdateCalendarEvent = nil
}

// UpdateCalendarEventReq ...
type UpdateCalendarEventReq struct {
	CalendarID       string                            `path:"calendar_id" json:"-"`        // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	EventID          string                            `path:"event_id" json:"-"`           // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction), 示例值："00592a0e-7edf-4678-bc9d-1b77383ef08e_0"
	Summary          *string                           `json:"summary,omitempty"`           // 日程标题, 示例值："日程标题", 最大长度：`1000` 字符
	Description      *string                           `json:"description,omitempty"`       // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失, 示例值："日程描述", 最大长度：`40960` 字符
	NeedNotification *bool                             `json:"need_notification,omitempty"` // 更新日程是否给日程参与人发送bot通知，默认为true, 示例值：false
	StartTime        *UpdateCalendarEventReqStartTime  `json:"start_time,omitempty"`        // 日程开始时间
	EndTime          *UpdateCalendarEventReqEndTime    `json:"end_time,omitempty"`          // 日程结束时间
	Vchat            *UpdateCalendarEventReqVchat      `json:"vchat,omitempty"`             // 视频会议信息。
	Visibility       *string                           `json:"visibility,omitempty"`        // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："default", 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility  *string                           `json:"attendee_ability,omitempty"`  // 参与人权限, 示例值："can_see_others", 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus   *string                           `json:"free_busy_status,omitempty"`  // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 示例值："busy", 可选值有: `busy`：忙碌, `free`：空闲
	Location         *UpdateCalendarEventReqLocation   `json:"location,omitempty"`          // 日程地点
	Color            *int64                            `json:"color,omitempty"`             // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。, 示例值：-1
	Reminders        []*UpdateCalendarEventReqReminder `json:"reminders,omitempty"`         // 日程提醒列表
	Recurrence       *string                           `json:"recurrence,omitempty"`        // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。, 示例值："FREQ=DAILY;INTERVAL=1", 最大长度：`2000` 字符
	Schemas          []*UpdateCalendarEventReqSchema   `json:"schemas,omitempty"`           // 日程自定义信息；控制日程详情页的ui展示。
}

// UpdateCalendarEventReqStartTime ...
type UpdateCalendarEventReqStartTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1602504000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

// UpdateCalendarEventReqEndTime ...
type UpdateCalendarEventReqEndTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1602504000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

// UpdateCalendarEventReqVchat ...
type UpdateCalendarEventReqVchat struct {
	VCType      *string `json:"vc_type,omitempty"`     // 视频会议类型, 示例值："third_party", 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    *string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 示例值："vc", 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description *string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案, 示例值："发起视频会议", 长度范围：`0` ～ `500` 字符
	MeetingURL  *string `json:"meeting_url,omitempty"` // 视频会议URL, 示例值："https://example.com", 长度范围：`1` ～ `2000` 字符
}

// UpdateCalendarEventReqLocation ...
type UpdateCalendarEventReqLocation struct {
	Name      *string  `json:"name,omitempty"`      // 地点名称, 示例值："地点名称", 长度范围：`1` ～ `512` 字符
	Address   *string  `json:"address,omitempty"`   // 地点地址, 示例值："地点地址", 长度范围：`1` ～ `255` 字符
	Latitude  *float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：1.100000023841858
	Longitude *float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准, 示例值：2.200000047683716
}

// UpdateCalendarEventReqReminder ...
type UpdateCalendarEventReqReminder struct {
	Minutes *int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效, 示例值：5, 取值范围：`-20160` ～ `20160`
}

// UpdateCalendarEventReqSchema ...
type UpdateCalendarEventReqSchema struct {
	UiName   *string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域, 示例值："ForwardIcon"
	UiStatus *string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 示例值："hide", 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  *string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**, 示例值："https://applink.feishu.cn/client/calendar/event/detail?calendarId=xxxxxx&key=xxxxxx&originalTime=xxxxxx&startTime=xxxxxx", 最大长度：`2000` 字符
}

// updateCalendarEventResp ...
type updateCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *UpdateCalendarEventResp `json:"data,omitempty"`
}

// UpdateCalendarEventResp ...
type UpdateCalendarEventResp struct {
	Event *UpdateCalendarEventRespEvent `json:"event,omitempty"` // 更新后的日程实体
}

// UpdateCalendarEventRespEvent ...
type UpdateCalendarEventRespEvent struct {
	EventID             string                                  `json:"event_id,omitempty"`              // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction)
	OrganizerCalendarID string                                  `json:"organizer_calendar_id,omitempty"` // 日程组织者日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary             string                                  `json:"summary,omitempty"`               // 日程标题
	Description         string                                  `json:"description,omitempty"`           // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失
	NeedNotification    bool                                    `json:"need_notification,omitempty"`     // 更新日程是否给日程参与人发送bot通知，默认为true
	StartTime           *UpdateCalendarEventRespEventStartTime  `json:"start_time,omitempty"`            // 日程开始时间
	EndTime             *UpdateCalendarEventRespEventEndTime    `json:"end_time,omitempty"`              // 日程结束时间
	Vchat               *UpdateCalendarEventRespEventVchat      `json:"vchat,omitempty"`                 // 视频会议信息。
	Visibility          string                                  `json:"visibility,omitempty"`            // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility     string                                  `json:"attendee_ability,omitempty"`      // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus      string                                  `json:"free_busy_status,omitempty"`      // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location            *UpdateCalendarEventRespEventLocation   `json:"location,omitempty"`              // 日程地点
	Color               int64                                   `json:"color,omitempty"`                 // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders           []*UpdateCalendarEventRespEventReminder `json:"reminders,omitempty"`             // 日程提醒列表
	Recurrence          string                                  `json:"recurrence,omitempty"`            // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status              string                                  `json:"status,omitempty"`                // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException         bool                                    `json:"is_exception,omitempty"`          // 日程是否是一个重复日程的例外日程
	RecurringEventID    string                                  `json:"recurring_event_id,omitempty"`    // 例外日程的原重复日程的event_id
	Schemas             []*UpdateCalendarEventRespEventSchema   `json:"schemas,omitempty"`               // 日程自定义信息；控制日程详情页的ui展示。
}

// UpdateCalendarEventRespEventStartTime ...
type UpdateCalendarEventRespEventStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// UpdateCalendarEventRespEventEndTime ...
type UpdateCalendarEventRespEventEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// UpdateCalendarEventRespEventVchat ...
type UpdateCalendarEventRespEventVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

// UpdateCalendarEventRespEventLocation ...
type UpdateCalendarEventRespEventLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

// UpdateCalendarEventRespEventReminder ...
type UpdateCalendarEventRespEventReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

// UpdateCalendarEventRespEventSchema ...
type UpdateCalendarEventRespEventSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SearchCalendarEvent
//
// 该接口用于以用户身份搜索某日历下的相关日程。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有reader、writer或owner权限（调用[获取日历](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get)接口，role字段可查看权限）。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/search
func (r *CalendarService) SearchCalendarEvent(ctx context.Context, request *SearchCalendarEventReq, options ...MethodOptionFunc) (*SearchCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarSearchCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SearchCalendarEvent mock enable")
		return r.cli.mock.mockCalendarSearchCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SearchCalendarEvent",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/search",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(searchCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarSearchCalendarEvent mock CalendarSearchCalendarEvent method
func (r *Mock) MockCalendarSearchCalendarEvent(f func(ctx context.Context, request *SearchCalendarEventReq, options ...MethodOptionFunc) (*SearchCalendarEventResp, *Response, error)) {
	r.mockCalendarSearchCalendarEvent = f
}

// UnMockCalendarSearchCalendarEvent un-mock CalendarSearchCalendarEvent method
func (r *Mock) UnMockCalendarSearchCalendarEvent() {
	r.mockCalendarSearchCalendarEvent = nil
}

// SearchCalendarEventReq ...
type SearchCalendarEventReq struct {
	UserIDType *IDType                       `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	PageToken  *string                       `query:"page_token" json:"-"`   // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："xxxxx"
	PageSize   *int64                        `query:"page_size" json:"-"`    // 分页大小, 示例值：10, 最大值：`100`
	CalendarID string                        `path:"calendar_id" json:"-"`   // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	Query      string                        `json:"query,omitempty"`        // 搜索关键字, 示例值："query words", 长度范围：`0` ～ `200` 字符
	Filter     *SearchCalendarEventReqFilter `json:"filter,omitempty"`       // 搜索过滤器
}

// SearchCalendarEventReqFilter ...
type SearchCalendarEventReqFilter struct {
	StartTime *SearchCalendarEventReqFilterStartTime `json:"start_time,omitempty"` // 搜索过滤项，日程搜索区间的开始时间，被搜索日程的事件必须与搜索区间有交集
	EndTime   *SearchCalendarEventReqFilterEndTime   `json:"end_time,omitempty"`   // 搜索过滤项，日程搜索区间的结束时间，被搜索日程的事件必须与搜索区间有交集
	UserIDs   []string                               `json:"user_ids,omitempty"`   // 搜索过滤项，参与人的用户ID列表，被搜索日程中必须包含至少一个其中的参与人。参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 示例值：xxxxx
	RoomIDs   []string                               `json:"room_ids,omitempty"`   // 搜索过滤项，会议室ID列表，被搜索日程中必须包含至少一个其中的会议室, 示例值：xxxxx
	ChatIDs   []string                               `json:"chat_ids,omitempty"`   // 搜索过滤项，群ID列表，被搜索日程的参与人中必须包含至少一个其中的群。参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description), 示例值：xxxxx
}

// SearchCalendarEventReqFilterStartTime ...
type SearchCalendarEventReqFilterStartTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1602504000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

// SearchCalendarEventReqFilterEndTime ...
type SearchCalendarEventReqFilterEndTime struct {
	Date      *string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定, 示例值："2018-09-01"
	Timestamp *string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区), 示例值："1602504000"
	Timezone  *string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai, 示例值："Asia/Shanghai"
}

// searchCalendarEventResp ...
type searchCalendarEventResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *SearchCalendarEventResp `json:"data,omitempty"`
}

// SearchCalendarEventResp ...
type SearchCalendarEventResp struct {
	Items     []*SearchCalendarEventRespItem `json:"items,omitempty"`      // 搜索命中的日程列表
	PageToken string                         `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

// SearchCalendarEventRespItem ...
type SearchCalendarEventRespItem struct {
	EventID             string                                 `json:"event_id,omitempty"`              // 日程ID。参见[日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/introduction)
	OrganizerCalendarID string                                 `json:"organizer_calendar_id,omitempty"` // 日程组织者日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary             string                                 `json:"summary,omitempty"`               // 日程标题
	Description         string                                 `json:"description,omitempty"`           // 日程描述；目前不支持编辑富文本描述，如果日程描述通过客户端编辑过，更新描述会导致富文本格式丢失
	NeedNotification    bool                                   `json:"need_notification,omitempty"`     // 更新日程是否给日程参与人发送bot通知，默认为true
	StartTime           *SearchCalendarEventRespItemStartTime  `json:"start_time,omitempty"`            // 日程开始时间
	EndTime             *SearchCalendarEventRespItemEndTime    `json:"end_time,omitempty"`              // 日程结束时间
	Vchat               *SearchCalendarEventRespItemVchat      `json:"vchat,omitempty"`                 // 视频会议信息。
	Visibility          string                                 `json:"visibility,omitempty"`            // 日程公开范围，新建日程默认为Default；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `default`：默认权限，跟随日历权限，默认仅向他人显示是否“忙碌”, `public`：公开，显示日程详情, `private`：私密，仅自己可见详情
	AttendeeAbility     string                                 `json:"attendee_ability,omitempty"`      // 参与人权限, 可选值有: `none`：无法编辑日程、无法邀请其它参与人、无法查看参与人列表, `can_see_others`：无法编辑日程、无法邀请其它参与人、可以查看参与人列表, `can_invite_others`：无法编辑日程、可以邀请其它参与人、可以查看参与人列表, `can_modify_event`：可以编辑日程、可以邀请其它参与人、可以查看参与人列表
	FreeBusyStatus      string                                 `json:"free_busy_status,omitempty"`      // 日程占用的忙闲状态，新建日程默认为Busy；仅新建日程时对所有参与人生效，之后修改该属性仅对当前身份生效, 可选值有: `busy`：忙碌, `free`：空闲
	Location            *SearchCalendarEventRespItemLocation   `json:"location,omitempty"`              // 日程地点
	Color               int64                                  `json:"color,omitempty"`                 // 日程颜色，颜色RGB值的int32表示。仅对当前身份生效；客户端展示时会映射到色板上最接近的一种颜色；值为0或-1时默认跟随日历颜色。
	Reminders           []*SearchCalendarEventRespItemReminder `json:"reminders,omitempty"`             // 日程提醒列表
	Recurrence          string                                 `json:"recurrence,omitempty"`            // 重复日程的重复性规则；参考[rfc5545](https://datatracker.ietf.org/doc/html/rfc5545#section-3.3.10)；, 不支持COUNT和UNTIL同时出现；, 预定会议室重复日程长度不得超过两年。
	Status              string                                 `json:"status,omitempty"`                // 日程状态, 可选值有: `tentative`：未回应, `confirmed`：已确认, `cancelled`：日程已取消
	IsException         bool                                   `json:"is_exception,omitempty"`          // 日程是否是一个重复日程的例外日程
	RecurringEventID    string                                 `json:"recurring_event_id,omitempty"`    // 例外日程的原重复日程的event_id
	Schemas             []*SearchCalendarEventRespItemSchema   `json:"schemas,omitempty"`               // 日程自定义信息；控制日程详情页的ui展示。
}

// SearchCalendarEventRespItemStartTime ...
type SearchCalendarEventRespItemStartTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// SearchCalendarEventRespItemEndTime ...
type SearchCalendarEventRespItemEndTime struct {
	Date      string `json:"date,omitempty"`      // 仅全天日程使用该字段，如2018-09-01。需满足 RFC3339 格式。不能与 timestamp 同时指定
	Timestamp string `json:"timestamp,omitempty"` // 秒级时间戳，如1602504000(表示2020/10/12 20:0:00 +8时区)
	Timezone  string `json:"timezone,omitempty"`  // 时区名称，使用IANA Time Zone Database标准，如Asia/Shanghai；全天日程时区固定为UTC，非全天日程时区默认为Asia/Shanghai
}

// SearchCalendarEventRespItemVchat ...
type SearchCalendarEventRespItemVchat struct {
	VCType      string `json:"vc_type,omitempty"`     // 视频会议类型, 可选值有: `vc`：飞书视频会议，取该类型时，其他字段无效。, `third_party`：第三方链接视频会议，取该类型时，icon_type、description、meeting_url字段生效。, `no_meeting`：无视频会议，取该类型时，其他字段无效。, `lark_live`：飞书直播，内部类型，飞书客户端使用，API不支持创建，只读。, `unknown`：未知类型，做兼容使用，飞书客户端使用，API不支持创建，只读。
	IconType    string `json:"icon_type,omitempty"`   // 第三方视频会议icon类型；可以为空，为空展示默认icon。, 可选值有: `vc`：飞书视频会议icon, `live`：直播视频会议icon, `default`：默认icon
	Description string `json:"description,omitempty"` // 第三方视频会议文案，可以为空，为空展示默认文案
	MeetingURL  string `json:"meeting_url,omitempty"` // 视频会议URL
}

// SearchCalendarEventRespItemLocation ...
type SearchCalendarEventRespItemLocation struct {
	Name      string  `json:"name,omitempty"`      // 地点名称
	Address   string  `json:"address,omitempty"`   // 地点地址
	Latitude  float64 `json:"latitude,omitempty"`  // 地点坐标纬度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
	Longitude float64 `json:"longitude,omitempty"` // 地点坐标经度信息，对于国内的地点，采用GCJ-02标准，海外地点采用WGS84标准
}

// SearchCalendarEventRespItemReminder ...
type SearchCalendarEventRespItemReminder struct {
	Minutes int64 `json:"minutes,omitempty"` // 日程提醒时间的偏移量，正数时表示在日程开始前X分钟提醒，负数时表示在日程开始后X分钟提醒,新建或更新日程时传入该字段，仅对当前身份生效
}

// SearchCalendarEventRespItemSchema ...
type SearchCalendarEventRespItemSchema struct {
	UiName   string `json:"ui_name,omitempty"`   // UI名称。取值范围如下： , ForwardIcon: 日程转发按钮 , MeetingChatIcon: 会议群聊按钮 , MeetingMinutesIcon: 会议纪要按钮 , MeetingVideo: 视频会议区域 , RSVP: 接受/拒绝/待定区域 , Attendee: 参与者区域 , OrganizerOrCreator: 组织者/创建者区域
	UiStatus string `json:"ui_status,omitempty"` // UI项自定义状态。**目前只支持hide**, 可选值有: `hide`：隐藏显示, `readonly`：只读, `editable`：可编辑, `unknown`：未知UI项自定义状态，仅用于读取时兼容
	AppLink  string `json:"app_link,omitempty"`  // 按钮点击后跳转的链接; **该字段暂不支持传入。**
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendarEvent 该接口用于以用户身份订阅指定日历下的日程变更事件。
//
// 当前身份必须对日历有reader、writer或owner权限（调用[获取日历](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get)接口，role字段可查看权限）。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar-event/subscription
func (r *CalendarService) SubscribeCalendarEvent(ctx context.Context, request *SubscribeCalendarEventReq, options ...MethodOptionFunc) (*SubscribeCalendarEventResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendarEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendarEvent mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendarEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SubscribeCalendarEvent",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/events/subscription",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(subscribeCalendarEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarSubscribeCalendarEvent mock CalendarSubscribeCalendarEvent method
func (r *Mock) MockCalendarSubscribeCalendarEvent(f func(ctx context.Context, request *SubscribeCalendarEventReq, options ...MethodOptionFunc) (*SubscribeCalendarEventResp, *Response, error)) {
	r.mockCalendarSubscribeCalendarEvent = f
}

// UnMockCalendarSubscribeCalendarEvent un-mock CalendarSubscribeCalendarEvent method
func (r *Mock) UnMockCalendarSubscribeCalendarEvent() {
	r.mockCalendarSubscribeCalendarEvent = nil
}

// SubscribeCalendarEventReq ...
type SubscribeCalendarEventReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// subscribeCalendarEventResp ...
type subscribeCalendarEventResp struct {
	Code int64                       `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                      `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarEventResp `json:"data,omitempty"`
}

// SubscribeCalendarEventResp ...
type SubscribeCalendarEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarFreeBusyList 查询用户主日历或会议室的忙闲信息。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/freebusy/list
func (r *CalendarService) GetCalendarFreeBusyList(ctx context.Context, request *GetCalendarFreeBusyListReq, options ...MethodOptionFunc) (*GetCalendarFreeBusyListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarFreeBusyList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarFreeBusyList mock enable")
		return r.cli.mock.mockCalendarGetCalendarFreeBusyList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarFreeBusyList",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/freebusy/list",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(getCalendarFreeBusyListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarFreeBusyList mock CalendarGetCalendarFreeBusyList method
func (r *Mock) MockCalendarGetCalendarFreeBusyList(f func(ctx context.Context, request *GetCalendarFreeBusyListReq, options ...MethodOptionFunc) (*GetCalendarFreeBusyListResp, *Response, error)) {
	r.mockCalendarGetCalendarFreeBusyList = f
}

// UnMockCalendarGetCalendarFreeBusyList un-mock CalendarGetCalendarFreeBusyList method
func (r *Mock) UnMockCalendarGetCalendarFreeBusyList() {
	r.mockCalendarGetCalendarFreeBusyList = nil
}

// GetCalendarFreeBusyListReq ...
type GetCalendarFreeBusyListReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	TimeMin    string  `json:"time_min,omitempty"`     // 查询时段开始时间，需要url编码, 示例值："2020-10-28T12:00:00+08:00"
	TimeMax    string  `json:"time_max,omitempty"`     // 查询时段结束时间，需要url编码, 示例值："2020-12-28T12:00:00+08:00"
	UserID     *string `json:"user_id,omitempty"`      // 用户user_id，输入时与 room_id 二选一。参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 示例值："ou_xxxxxxxxxx"
	RoomID     *string `json:"room_id,omitempty"`      // 会议室room_id，输入时与 user_id 二选一, 示例值："omm_xxxxxxxxxx"
}

// getCalendarFreeBusyListResp ...
type getCalendarFreeBusyListResp struct {
	Code int64                        `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                       `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarFreeBusyListResp `json:"data,omitempty"`
}

// GetCalendarFreeBusyListResp ...
type GetCalendarFreeBusyListResp struct {
	FreebusyList []*GetCalendarFreeBusyListRespFreebusy `json:"freebusy_list,omitempty"` // 日历上请求时间区间内的忙碌时间段信息。
}

// GetCalendarFreeBusyListRespFreebusy ...
type GetCalendarFreeBusyListRespFreebusy struct {
	StartTime string `json:"start_time,omitempty"` // 忙闲信息开始时间，RFC3339 date_time 格式
	EndTime   string `json:"end_time,omitempty"`   // 忙闲信息结束时间，RFC3339 date_time 格式
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendar
//
// 该接口用于以当前身份（应用 / 用户）根据日历 ID 获取日历信息。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份必须对日历有访问权限。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/get
func (r *CalendarService) GetCalendar(ctx context.Context, request *GetCalendarReq, options ...MethodOptionFunc) (*GetCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendar mock enable")
		return r.cli.mock.mockCalendarGetCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendar",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendar mock CalendarGetCalendar method
func (r *Mock) MockCalendarGetCalendar(f func(ctx context.Context, request *GetCalendarReq, options ...MethodOptionFunc) (*GetCalendarResp, *Response, error)) {
	r.mockCalendarGetCalendar = f
}

// UnMockCalendarGetCalendar un-mock CalendarGetCalendar method
func (r *Mock) UnMockCalendarGetCalendar() {
	r.mockCalendarGetCalendar = nil
}

// GetCalendarReq ...
type GetCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// getCalendarResp ...
type getCalendarResp struct {
	Code int64            `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string           `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarResp `json:"data,omitempty"`
}

// GetCalendarResp ...
type GetCalendarResp struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarList
//
// 该接口用于分页获得当前身份（应用 / 用户）的日历列表。
// 身份由 Header Authorization 的 Token 类型决定。
// 调用时首先使用 page_token 分页拉取存量数据，之后使用 sync_token 增量同步变更数据。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/list
func (r *CalendarService) GetCalendarList(ctx context.Context, request *GetCalendarListReq, options ...MethodOptionFunc) (*GetCalendarListResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarList mock enable")
		return r.cli.mock.mockCalendarGetCalendarList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetCalendarList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getCalendarListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarList mock CalendarGetCalendarList method
func (r *Mock) MockCalendarGetCalendarList(f func(ctx context.Context, request *GetCalendarListReq, options ...MethodOptionFunc) (*GetCalendarListResp, *Response, error)) {
	r.mockCalendarGetCalendarList = f
}

// UnMockCalendarGetCalendarList un-mock CalendarGetCalendarList method
func (r *Mock) UnMockCalendarGetCalendarList() {
	r.mockCalendarGetCalendarList = nil
}

// GetCalendarListReq ...
type GetCalendarListReq struct {
	PageSize  *int64  `query:"page_size" json:"-"`  // 一次请求要求返回最大数量，默认500，取值范围为[50. 1000], 示例值：50, 默认值: `500`, 取值范围：`50` ～ `1000`
	PageToken *string `query:"page_token" json:"-"` // 上次请求Response返回的分页标记，首次请求时为空, 示例值："ListCalendarsPageToken_xxx"
	SyncToken *string `query:"sync_token" json:"-"` // 上次请求Response返回的增量同步标记，分页请求未结束时为空, 示例值："ListCalendarsSyncToken_xxx"
}

// getCalendarListResp ...
type getCalendarListResp struct {
	Code int64                `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string               `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarListResp `json:"data,omitempty"`
}

// GetCalendarListResp ...
type GetCalendarListResp struct {
	HasMore      bool                           `json:"has_more,omitempty"`      // 是否还有更多数据
	PageToken    string                         `json:"page_token,omitempty"`    // 下次请求需要带上的分页标记，90 天有效期
	SyncToken    string                         `json:"sync_token,omitempty"`    // 下次请求需要带上的增量同步标记，90 天有效期
	CalendarList []*GetCalendarListRespCalendar `json:"calendar_list,omitempty"` // 分页加载的日历数据列表
}

// GetCalendarListRespCalendar ...
type GetCalendarListRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateCalendar
//
// 该接口用于以当前身份（应用 / 用户）修改日历信息。
// 身份由 Header Authorization 的 Token 类型决定。
// 当前身份对日历有 owner 权限时，可修改全局字段：summary, description, permission。
// 当前身份对日历不具有 owner 权限时，仅可修改对自己生效的字段：color, summary_alias。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/patch
func (r *CalendarService) UpdateCalendar(ctx context.Context, request *UpdateCalendarReq, options ...MethodOptionFunc) (*UpdateCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarUpdateCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#UpdateCalendar mock enable")
		return r.cli.mock.mockCalendarUpdateCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "UpdateCalendar",
		Method:                "PATCH",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarUpdateCalendar mock CalendarUpdateCalendar method
func (r *Mock) MockCalendarUpdateCalendar(f func(ctx context.Context, request *UpdateCalendarReq, options ...MethodOptionFunc) (*UpdateCalendarResp, *Response, error)) {
	r.mockCalendarUpdateCalendar = f
}

// UnMockCalendarUpdateCalendar un-mock CalendarUpdateCalendar method
func (r *Mock) UnMockCalendarUpdateCalendar() {
	r.mockCalendarUpdateCalendar = nil
}

// UpdateCalendarReq ...
type UpdateCalendarReq struct {
	CalendarID   string              `path:"calendar_id" json:"-"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
	Summary      *string             `json:"summary,omitempty"`       // 日历标题, 示例值："测试日历", 长度范围：`1` ～ `255` 字符
	Description  *string             `json:"description,omitempty"`   // 日历描述, 示例值："使用开放接口创建日历", 最大长度：`255` 字符
	Permissions  *CalendarPermission `json:"permissions,omitempty"`   // 日历公开范围, 示例值："private", 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        *int64              `json:"color,omitempty"`         // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效, 示例值：-1
	SummaryAlias *string             `json:"summary_alias,omitempty"` // 日历备注名，修改或添加后仅对当前身份生效, 示例值："日历备注名", 最大长度：`255` 字符
}

// updateCalendarResp ...
type updateCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *UpdateCalendarResp `json:"data,omitempty"`
}

// UpdateCalendarResp ...
type UpdateCalendarResp struct {
	Calendar *UpdateCalendarRespCalendar `json:"calendar,omitempty"` // 更新后的日历实体
}

// UpdateCalendarRespCalendar ...
type UpdateCalendarRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetPrimaryCalendar 获取当前身份的主日历信息。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/primary
func (r *CalendarService) GetPrimaryCalendar(ctx context.Context, request *GetPrimaryCalendarReq, options ...MethodOptionFunc) (*GetPrimaryCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarGetPrimaryCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetPrimaryCalendar mock enable")
		return r.cli.mock.mockCalendarGetPrimaryCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "GetPrimaryCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/primary",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getPrimaryCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetPrimaryCalendar mock CalendarGetPrimaryCalendar method
func (r *Mock) MockCalendarGetPrimaryCalendar(f func(ctx context.Context, request *GetPrimaryCalendarReq, options ...MethodOptionFunc) (*GetPrimaryCalendarResp, *Response, error)) {
	r.mockCalendarGetPrimaryCalendar = f
}

// UnMockCalendarGetPrimaryCalendar un-mock CalendarGetPrimaryCalendar method
func (r *Mock) UnMockCalendarGetPrimaryCalendar() {
	r.mockCalendarGetPrimaryCalendar = nil
}

// GetPrimaryCalendarReq ...
type GetPrimaryCalendarReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
}

// getPrimaryCalendarResp ...
type getPrimaryCalendarResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *GetPrimaryCalendarResp `json:"data,omitempty"`
}

// GetPrimaryCalendarResp ...
type GetPrimaryCalendarResp struct {
	Calendars []*GetPrimaryCalendarRespCalendar `json:"calendars,omitempty"` // 主日历列表
}

// GetPrimaryCalendarRespCalendar ...
type GetPrimaryCalendarRespCalendar struct {
	Calendar *GetPrimaryCalendarRespCalendarCalendar `json:"calendar,omitempty"` // 日历实体信息
	UserID   string                                  `json:"user_id,omitempty"`  // 日历的创建者user ID，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
}

// GetPrimaryCalendarRespCalendarCalendar ...
type GetPrimaryCalendarRespCalendarCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SearchCalendar 该接口用于通过关键字查询公共日历或用户主日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/search
func (r *CalendarService) SearchCalendar(ctx context.Context, request *SearchCalendarReq, options ...MethodOptionFunc) (*SearchCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarSearchCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SearchCalendar mock enable")
		return r.cli.mock.mockCalendarSearchCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "SearchCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/search",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(searchCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarSearchCalendar mock CalendarSearchCalendar method
func (r *Mock) MockCalendarSearchCalendar(f func(ctx context.Context, request *SearchCalendarReq, options ...MethodOptionFunc) (*SearchCalendarResp, *Response, error)) {
	r.mockCalendarSearchCalendar = f
}

// UnMockCalendarSearchCalendar un-mock CalendarSearchCalendar method
func (r *Mock) UnMockCalendarSearchCalendar() {
	r.mockCalendarSearchCalendar = nil
}

// SearchCalendarReq ...
type SearchCalendarReq struct {
	PageToken *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："10"
	PageSize  *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`50`
	Query     string  `json:"query,omitempty"`      // 搜索关键字, 示例值："query words", 长度范围：`1` ～ `200` 字符
}

// searchCalendarResp ...
type searchCalendarResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *SearchCalendarResp `json:"data,omitempty"`
}

// SearchCalendarResp ...
type SearchCalendarResp struct {
	Items     []*SearchCalendarRespItem `json:"items,omitempty"`      // 搜索命中的日历列表
	PageToken string                    `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
}

// SearchCalendarRespItem ...
type SearchCalendarRespItem struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendar
//
// 该接口用于以当前身份（应用 / 用户）订阅某个日历。
// 身份由 Header Authorization 的 Token 类型决定。
// 仅可订阅类型为 primary 或 shared 的公开日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/subscribe
func (r *CalendarService) SubscribeCalendar(ctx context.Context, request *SubscribeCalendarReq, options ...MethodOptionFunc) (*SubscribeCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendar mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "SubscribeCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/subscribe",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(subscribeCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarSubscribeCalendar mock CalendarSubscribeCalendar method
func (r *Mock) MockCalendarSubscribeCalendar(f func(ctx context.Context, request *SubscribeCalendarReq, options ...MethodOptionFunc) (*SubscribeCalendarResp, *Response, error)) {
	r.mockCalendarSubscribeCalendar = f
}

// UnMockCalendarSubscribeCalendar un-mock CalendarSubscribeCalendar method
func (r *Mock) UnMockCalendarSubscribeCalendar() {
	r.mockCalendarSubscribeCalendar = nil
}

// SubscribeCalendarReq ...
type SubscribeCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// subscribeCalendarResp ...
type subscribeCalendarResp struct {
	Code int64                  `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarResp `json:"data,omitempty"`
}

// SubscribeCalendarResp ...
type SubscribeCalendarResp struct {
	Calendar *SubscribeCalendarRespCalendar `json:"calendar,omitempty"` // 订阅的日历实体
}

// SubscribeCalendarRespCalendar ...
type SubscribeCalendarRespCalendar struct {
	CalendarID   string             `json:"calendar_id,omitempty"`    // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction)
	Summary      string             `json:"summary,omitempty"`        // 日历标题
	Description  string             `json:"description,omitempty"`    // 日历描述
	Permissions  CalendarPermission `json:"permissions,omitempty"`    // 日历公开范围, 可选值有: `private`：私密, `show_only_free_busy`：仅展示忙闲信息, `public`：他人可查看日程详情
	Color        int64              `json:"color,omitempty"`          // 日历颜色，颜色RGB值的int32表示。客户端展示时会映射到色板上最接近的一种颜色。仅对当前身份生效
	Type         CalendarType       `json:"type,omitempty"`           // 日历类型, 可选值有: `unknown`：未知类型, `primary`：用户或应用的主日历, `shared`：由用户或应用创建的共享日历, `google`：用户绑定的谷歌日历, `resource`：会议室日历, `exchange`：用户绑定的Exchange日历
	SummaryAlias string             `json:"summary_alias,omitempty"`  // 日历备注名，修改或添加后仅对当前身份生效
	IsDeleted    bool               `json:"is_deleted,omitempty"`     // 对于当前身份，日历是否已经被标记为删除
	IsThirdParty bool               `json:"is_third_party,omitempty"` // 当前日历是否是第三方数据；三方日历及日程只支持读，不支持写入
	Role         CalendarRole       `json:"role,omitempty"`           // 当前身份对于该日历的访问权限, 可选值有: `unknown`：未知权限, `free_busy_reader`：游客，只能看到忙碌/空闲信息, `reader`：订阅者，查看所有日程详情, `writer`：编辑者，创建及修改日程, `owner`：管理员，管理日历及共享设置
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// SubscribeCalendarChangeEvent 该接口用于以用户身份订阅当前身份下日历列表中的所有日历变更。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/subscription
func (r *CalendarService) SubscribeCalendarChangeEvent(ctx context.Context, request *SubscribeCalendarChangeEventReq, options ...MethodOptionFunc) (*SubscribeCalendarChangeEventResp, *Response, error) {
	if r.cli.mock.mockCalendarSubscribeCalendarChangeEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#SubscribeCalendarChangeEvent mock enable")
		return r.cli.mock.mockCalendarSubscribeCalendarChangeEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "SubscribeCalendarChangeEvent",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/subscription",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(subscribeCalendarChangeEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarSubscribeCalendarChangeEvent mock CalendarSubscribeCalendarChangeEvent method
func (r *Mock) MockCalendarSubscribeCalendarChangeEvent(f func(ctx context.Context, request *SubscribeCalendarChangeEventReq, options ...MethodOptionFunc) (*SubscribeCalendarChangeEventResp, *Response, error)) {
	r.mockCalendarSubscribeCalendarChangeEvent = f
}

// UnMockCalendarSubscribeCalendarChangeEvent un-mock CalendarSubscribeCalendarChangeEvent method
func (r *Mock) UnMockCalendarSubscribeCalendarChangeEvent() {
	r.mockCalendarSubscribeCalendarChangeEvent = nil
}

// SubscribeCalendarChangeEventReq ...
type SubscribeCalendarChangeEventReq struct{}

// subscribeCalendarChangeEventResp ...
type subscribeCalendarChangeEventResp struct {
	Code int64                             `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                            `json:"msg,omitempty"`  // 错误描述
	Data *SubscribeCalendarChangeEventResp `json:"data,omitempty"`
}

// SubscribeCalendarChangeEventResp ...
type SubscribeCalendarChangeEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarTimeoffEvent 为指定用户创建一个请假日程，可以是一个普通请假日程，也可以是一个全天日程。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/timeoff_event/create
func (r *CalendarService) CreateCalendarTimeoffEvent(ctx context.Context, request *CreateCalendarTimeoffEventReq, options ...MethodOptionFunc) (*CreateCalendarTimeoffEventResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarTimeoffEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarTimeoffEvent mock enable")
		return r.cli.mock.mockCalendarCreateCalendarTimeoffEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "CreateCalendarTimeoffEvent",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/timeoff_events",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(createCalendarTimeoffEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarCreateCalendarTimeoffEvent mock CalendarCreateCalendarTimeoffEvent method
func (r *Mock) MockCalendarCreateCalendarTimeoffEvent(f func(ctx context.Context, request *CreateCalendarTimeoffEventReq, options ...MethodOptionFunc) (*CreateCalendarTimeoffEventResp, *Response, error)) {
	r.mockCalendarCreateCalendarTimeoffEvent = f
}

// UnMockCalendarCreateCalendarTimeoffEvent un-mock CalendarCreateCalendarTimeoffEvent method
func (r *Mock) UnMockCalendarCreateCalendarTimeoffEvent() {
	r.mockCalendarCreateCalendarTimeoffEvent = nil
}

// CreateCalendarTimeoffEventReq ...
type CreateCalendarTimeoffEventReq struct {
	UserIDType  *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	UserID      string  `json:"user_id,omitempty"`      // 用户id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 示例值："ou_XXXXXXXXXX"
	Timezone    string  `json:"timezone,omitempty"`     // 时区, 示例值："Asia/Shanghai"
	StartTime   string  `json:"start_time,omitempty"`   // 休假开始时间: 有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。, 示例值："2021-01-01"
	EndTime     string  `json:"end_time,omitempty"`     // 休假结束时间：,有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。, 示例值："2021-01-01"
	Title       *string `json:"title,omitempty"`        // 自定义请假日程标题，没有设置则为默认日程标题, 示例值："请假中(全天) / 1-Day Time Off"
	Description *string `json:"description,omitempty"`  // 自定义请假日程描述，没有设置则为默认日程描述, 示例值："若删除此日程，飞书中相应的“请假”标签将自动消失，而请假系统中的休假申请不会被撤销。"
}

// createCalendarTimeoffEventResp ...
type createCalendarTimeoffEventResp struct {
	Code int64                           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                          `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarTimeoffEventResp `json:"data,omitempty"`
}

// CreateCalendarTimeoffEventResp ...
type CreateCalendarTimeoffEventResp struct {
	TimeoffEventID string `json:"timeoff_event_id,omitempty"` // 请假日程ID。参见[请假日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/timeoff_event/introduction#b6611a02)
	UserID         string `json:"user_id,omitempty"`          // 用户id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	Timezone       string `json:"timezone,omitempty"`         // 时区
	StartTime      string `json:"start_time,omitempty"`       // 休假开始时间: 有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。
	EndTime        string `json:"end_time,omitempty"`         // 休假结束时间：,有时间戳(1609430400)和日期(2021-01-01)两种格式，其它格式无效；,时间戳格式是按小时休假日程，日期格式是全天休假日程；,start_time与end_time格式需保持一致，否则无效。
	Title          string `json:"title,omitempty"`            // 自定义请假日程标题，没有设置则为默认日程标题
	Description    string `json:"description,omitempty"`      // 自定义请假日程描述，没有设置则为默认日程描述
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarTimeoffEvent 删除一个指定的请假日程，请假日程删除，用户个人签名页的请假信息也会消失。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/timeoff_event/delete
func (r *CalendarService) DeleteCalendarTimeoffEvent(ctx context.Context, request *DeleteCalendarTimeoffEventReq, options ...MethodOptionFunc) (*DeleteCalendarTimeoffEventResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarTimeoffEvent != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarTimeoffEvent mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarTimeoffEvent(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "DeleteCalendarTimeoffEvent",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/timeoff_events/:timeoff_event_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(deleteCalendarTimeoffEventResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarDeleteCalendarTimeoffEvent mock CalendarDeleteCalendarTimeoffEvent method
func (r *Mock) MockCalendarDeleteCalendarTimeoffEvent(f func(ctx context.Context, request *DeleteCalendarTimeoffEventReq, options ...MethodOptionFunc) (*DeleteCalendarTimeoffEventResp, *Response, error)) {
	r.mockCalendarDeleteCalendarTimeoffEvent = f
}

// UnMockCalendarDeleteCalendarTimeoffEvent un-mock CalendarDeleteCalendarTimeoffEvent method
func (r *Mock) UnMockCalendarDeleteCalendarTimeoffEvent() {
	r.mockCalendarDeleteCalendarTimeoffEvent = nil
}

// DeleteCalendarTimeoffEventReq ...
type DeleteCalendarTimeoffEventReq struct {
	TimeoffEventID string `path:"timeoff_event_id" json:"-"` // 休假申请的唯一标识id。参见[请假日程ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/timeoff_event/introduction#b6611a02), 示例值："timeoff:XXXXXX-XXXX-0917-1623-aa493d591a39"
}

// deleteCalendarTimeoffEventResp ...
type deleteCalendarTimeoffEventResp struct {
	Code int64                           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                          `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarTimeoffEventResp `json:"data,omitempty"`
}

// DeleteCalendarTimeoffEventResp ...
type DeleteCalendarTimeoffEventResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UnsubscribeCalendar
//
// 该接口用于以当前身份（应用 / 用户）取消对某日历的订阅状态。
// 身份由 Header Authorization 的 Token 类型决定。
// 仅可操作已经被当前身份订阅的日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/unsubscribe
func (r *CalendarService) UnsubscribeCalendar(ctx context.Context, request *UnsubscribeCalendarReq, options ...MethodOptionFunc) (*UnsubscribeCalendarResp, *Response, error) {
	if r.cli.mock.mockCalendarUnsubscribeCalendar != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#UnsubscribeCalendar mock enable")
		return r.cli.mock.mockCalendarUnsubscribeCalendar(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Calendar",
		API:                   "UnsubscribeCalendar",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/calendar/v4/calendars/:calendar_id/unsubscribe",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(unsubscribeCalendarResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarUnsubscribeCalendar mock CalendarUnsubscribeCalendar method
func (r *Mock) MockCalendarUnsubscribeCalendar(f func(ctx context.Context, request *UnsubscribeCalendarReq, options ...MethodOptionFunc) (*UnsubscribeCalendarResp, *Response, error)) {
	r.mockCalendarUnsubscribeCalendar = f
}

// UnMockCalendarUnsubscribeCalendar un-mock CalendarUnsubscribeCalendar method
func (r *Mock) UnMockCalendarUnsubscribeCalendar() {
	r.mockCalendarUnsubscribeCalendar = nil
}

// UnsubscribeCalendarReq ...
type UnsubscribeCalendarReq struct {
	CalendarID string `path:"calendar_id" json:"-"` // 日历ID。参见[日历ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/calendar/introduction), 示例值："feishu.cn_xxxxxxxxxx@group.calendar.feishu.cn"
}

// unsubscribeCalendarResp ...
type unsubscribeCalendarResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *UnsubscribeCalendarResp `json:"data,omitempty"`
}

// UnsubscribeCalendarResp ...
type UnsubscribeCalendarResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateCalendarExchangeBinding 本接口将Exchange账户绑定到飞书账户，进而支持Exchange日历的导入
//
// 操作用户需要是企业超级管理员
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/create
func (r *CalendarService) CreateCalendarExchangeBinding(ctx context.Context, request *CreateCalendarExchangeBindingReq, options ...MethodOptionFunc) (*CreateCalendarExchangeBindingResp, *Response, error) {
	if r.cli.mock.mockCalendarCreateCalendarExchangeBinding != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#CreateCalendarExchangeBinding mock enable")
		return r.cli.mock.mockCalendarCreateCalendarExchangeBinding(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "CreateCalendarExchangeBinding",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/exchange_bindings",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(createCalendarExchangeBindingResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarCreateCalendarExchangeBinding mock CalendarCreateCalendarExchangeBinding method
func (r *Mock) MockCalendarCreateCalendarExchangeBinding(f func(ctx context.Context, request *CreateCalendarExchangeBindingReq, options ...MethodOptionFunc) (*CreateCalendarExchangeBindingResp, *Response, error)) {
	r.mockCalendarCreateCalendarExchangeBinding = f
}

// UnMockCalendarCreateCalendarExchangeBinding un-mock CalendarCreateCalendarExchangeBinding method
func (r *Mock) UnMockCalendarCreateCalendarExchangeBinding() {
	r.mockCalendarCreateCalendarExchangeBinding = nil
}

// CreateCalendarExchangeBindingReq ...
type CreateCalendarExchangeBindingReq struct {
	UserIDType      *IDType `query:"user_id_type" json:"-"`     // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	AdminAccount    *string `json:"admin_account,omitempty"`    // admin账户, 示例值："email_admin_example@outlook.com", 长度范围：`1` ～ `500` 字符
	ExchangeAccount *string `json:"exchange_account,omitempty"` // 用户绑定的exchange账户, 示例值："email_account_example@outlook.com", 长度范围：`1` ～ `500` 字符
	UserID          *string `json:"user_id,omitempty"`          // exchange账户绑定user唯一标识id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 示例值："ou_xxxxxxxxxxxxxxxxxx"
}

// createCalendarExchangeBindingResp ...
type createCalendarExchangeBindingResp struct {
	Code int64                              `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                             `json:"msg,omitempty"`  // 错误描述
	Data *CreateCalendarExchangeBindingResp `json:"data,omitempty"`
}

// CreateCalendarExchangeBindingResp ...
type CreateCalendarExchangeBindingResp struct {
	AdminAccount      string `json:"admin_account,omitempty"`       // admin账户, 字段权限要求: 获取用户邮箱信息
	ExchangeAccount   string `json:"exchange_account,omitempty"`    // 用户绑定的exchange账户, 字段权限要求: 获取用户邮箱信息
	UserID            string `json:"user_id,omitempty"`             // exchange账户绑定user唯一标识id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	Status            string `json:"status,omitempty"`              // exchange账户同步状态, 可选值有: `doing`：日历正在同步, `cal_done`：日历同步完成, `timespan_done`：近期时间段同步完成, `done`：日程同步完成, `err`：同步错误
	ExchangeBindingID string `json:"exchange_binding_id,omitempty"` // exchange绑定唯一标识id。参见[exchange绑定ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/introduction#12533d5e)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteCalendarExchangeBinding 本接口解除Exchange账户和飞书账户的绑定关系，Exchange账户解除绑定后才能绑定其他飞书账户
//
// 操作用户需要是企业超级管理员
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/delete
func (r *CalendarService) DeleteCalendarExchangeBinding(ctx context.Context, request *DeleteCalendarExchangeBindingReq, options ...MethodOptionFunc) (*DeleteCalendarExchangeBindingResp, *Response, error) {
	if r.cli.mock.mockCalendarDeleteCalendarExchangeBinding != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#DeleteCalendarExchangeBinding mock enable")
		return r.cli.mock.mockCalendarDeleteCalendarExchangeBinding(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "DeleteCalendarExchangeBinding",
		Method:              "DELETE",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/exchange_bindings/:exchange_binding_id",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(deleteCalendarExchangeBindingResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarDeleteCalendarExchangeBinding mock CalendarDeleteCalendarExchangeBinding method
func (r *Mock) MockCalendarDeleteCalendarExchangeBinding(f func(ctx context.Context, request *DeleteCalendarExchangeBindingReq, options ...MethodOptionFunc) (*DeleteCalendarExchangeBindingResp, *Response, error)) {
	r.mockCalendarDeleteCalendarExchangeBinding = f
}

// UnMockCalendarDeleteCalendarExchangeBinding un-mock CalendarDeleteCalendarExchangeBinding method
func (r *Mock) UnMockCalendarDeleteCalendarExchangeBinding() {
	r.mockCalendarDeleteCalendarExchangeBinding = nil
}

// DeleteCalendarExchangeBindingReq ...
type DeleteCalendarExchangeBindingReq struct {
	ExchangeBindingID string `path:"exchange_binding_id" json:"-"` // exchange绑定唯一标识id。参见[exchange绑定ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/introduction#12533d5e), 示例值："ZW1haWxfYWRtaW5fZXhhbXBsZUBvdXRsb29rLmNvbSBlbWFpbF9hY2NvdW50X2V4YW1wbGVAb3V0bG9vay5jb20="
}

// deleteCalendarExchangeBindingResp ...
type deleteCalendarExchangeBindingResp struct {
	Code int64                              `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                             `json:"msg,omitempty"`  // 错误描述
	Data *DeleteCalendarExchangeBindingResp `json:"data,omitempty"`
}

// DeleteCalendarExchangeBindingResp ...
type DeleteCalendarExchangeBindingResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetCalendarExchangeBinding 本接口获取Exchange账户的绑定状态，包括exchange日历是否同步完成。
//
// 操作用户需要是企业超级管理员
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/get
func (r *CalendarService) GetCalendarExchangeBinding(ctx context.Context, request *GetCalendarExchangeBindingReq, options ...MethodOptionFunc) (*GetCalendarExchangeBindingResp, *Response, error) {
	if r.cli.mock.mockCalendarGetCalendarExchangeBinding != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GetCalendarExchangeBinding mock enable")
		return r.cli.mock.mockCalendarGetCalendarExchangeBinding(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "GetCalendarExchangeBinding",
		Method:              "GET",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/exchange_bindings/:exchange_binding_id",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(getCalendarExchangeBindingResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGetCalendarExchangeBinding mock CalendarGetCalendarExchangeBinding method
func (r *Mock) MockCalendarGetCalendarExchangeBinding(f func(ctx context.Context, request *GetCalendarExchangeBindingReq, options ...MethodOptionFunc) (*GetCalendarExchangeBindingResp, *Response, error)) {
	r.mockCalendarGetCalendarExchangeBinding = f
}

// UnMockCalendarGetCalendarExchangeBinding un-mock CalendarGetCalendarExchangeBinding method
func (r *Mock) UnMockCalendarGetCalendarExchangeBinding() {
	r.mockCalendarGetCalendarExchangeBinding = nil
}

// GetCalendarExchangeBindingReq ...
type GetCalendarExchangeBindingReq struct {
	UserIDType        *IDType `query:"user_id_type" json:"-"`       // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	ExchangeBindingID string  `path:"exchange_binding_id" json:"-"` // exchange绑定唯一标识id。参见[exchange绑定ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/introduction#12533d5e), 示例值："ZW1haWxfYWRtaW5fZXhhbXBsZUBvdXRsb29rLmNvbSBlbWFpbF9hY2NvdW50X2V4YW1wbGVAb3V0bG9vay5jb20="
}

// getCalendarExchangeBindingResp ...
type getCalendarExchangeBindingResp struct {
	Code int64                           `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                          `json:"msg,omitempty"`  // 错误描述
	Data *GetCalendarExchangeBindingResp `json:"data,omitempty"`
}

// GetCalendarExchangeBindingResp ...
type GetCalendarExchangeBindingResp struct {
	AdminAccount      string `json:"admin_account,omitempty"`       // admin账户, 字段权限要求: 获取用户邮箱信息
	ExchangeAccount   string `json:"exchange_account,omitempty"`    // 用户绑定的exchange账户, 字段权限要求: 获取用户邮箱信息
	UserID            string `json:"user_id,omitempty"`             // exchange账户绑定user唯一标识id，参见[用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction)
	Status            string `json:"status,omitempty"`              // exchange账户同步状态, 可选值有: `doing`：日历正在同步, `cal_done`：日历同步完成, `timespan_done`：近期时间段同步完成, `done`：日程同步完成, `err`：同步错误
	ExchangeBindingID string `json:"exchange_binding_id,omitempty"` // exchange绑定唯一标识id。参见[exchange绑定ID说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/exchange_binding/introduction#12533d5e)
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GenerateCaldavConf 用于为当前用户生成一个CalDAV账号密码，用于将飞书日历信息同步到本地设备日历。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/calendar-v4/setting/generate_caldav_conf
func (r *CalendarService) GenerateCaldavConf(ctx context.Context, request *GenerateCaldavConfReq, options ...MethodOptionFunc) (*GenerateCaldavConfResp, *Response, error) {
	if r.cli.mock.mockCalendarGenerateCaldavConf != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Calendar#GenerateCaldavConf mock enable")
		return r.cli.mock.mockCalendarGenerateCaldavConf(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:               "Calendar",
		API:                 "GenerateCaldavConf",
		Method:              "POST",
		URL:                 r.cli.openBaseURL + "/open-apis/calendar/v4/settings/generate_caldav_conf",
		Body:                request,
		MethodOption:        newMethodOption(options),
		NeedUserAccessToken: true,
	}
	resp := new(generateCaldavConfResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockCalendarGenerateCaldavConf mock CalendarGenerateCaldavConf method
func (r *Mock) MockCalendarGenerateCaldavConf(f func(ctx context.Context, request *GenerateCaldavConfReq, options ...MethodOptionFunc) (*GenerateCaldavConfResp, *Response, error)) {
	r.mockCalendarGenerateCaldavConf = f
}

// UnMockCalendarGenerateCaldavConf un-mock CalendarGenerateCaldavConf method
func (r *Mock) UnMockCalendarGenerateCaldavConf() {
	r.mockCalendarGenerateCaldavConf = nil
}

// GenerateCaldavConfReq ...
type GenerateCaldavConfReq struct {
	DeviceName *string `json:"device_name,omitempty"` // 需要同步日历的设备名，在日历中展示用来管理密码, 示例值："iPhone", 最大长度：`100` 字符
}

// generateCaldavConfResp ...
type generateCaldavConfResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *GenerateCaldavConfResp `json:"data,omitempty"`
}

// GenerateCaldavConfResp ...
type GenerateCaldavConfResp struct {
	Password      string `json:"password,omitempty"`       // caldav密码
	UserName      string `json:"user_name,omitempty"`      // caldav用户名
	ServerAddress string `json:"server_address,omitempty"` // 服务器地址
	DeviceName    string `json:"device_name,omitempty"`    // 设备名
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetChatAnnouncement 获取会话中的群公告信息，公告信息格式与[云文档](https://open.feishu.cn/document/ukTMukTMukTM/uAzM5YjLwMTO24CMzkjN)格式相同。
//
// 注意事项：
// - 应用需要开启[机器人能力](https://open.feishu.cn/document/home/develop-a-bot-in-5-minutes/create-an-app)
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-announcement/get
func (r *ChatService) GetChatAnnouncement(ctx context.Context, request *GetChatAnnouncementReq, options ...MethodOptionFunc) (*GetChatAnnouncementResp, *Response, error) {
	if r.cli.mock.mockChatGetChatAnnouncement != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Chat#GetChatAnnouncement mock enable")
		return r.cli.mock.mockChatGetChatAnnouncement(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Chat",
		API:                   "GetChatAnnouncement",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/im/v1/chats/:chat_id/announcement",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getChatAnnouncementResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

// MockChatGetChatAnnouncement mock ChatGetChatAnnouncement method
func (r *Mock) MockChatGetChatAnnouncement(f func(ctx context.Context, request *GetChatAnnouncementReq, options ...MethodOptionFunc) (*GetChatAnnouncementResp, *Response, error)) {
	r.mockChatGetChatAnnouncement = f
}

// UnMockChatGetChatAnnouncement un-mock ChatGetChatAnnouncement method
func (r *Mock) UnMockChatGetChatAnnouncement() {
	r.mockChatGetChatAnnouncement = nil
}

// GetChatAnnouncementReq ...
type GetChatAnnouncementReq struct {
	UserIDType *IDType `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	ChatID     string  `path:"chat_id" json:"-"`       // 待获取公告的群 ID，详情参见[群ID 说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-id-description), 示例值："oc_5ad11d72b830411d72b836c20"
}

// getChatAnnouncementResp ...
type getChatAnnouncementResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *GetChatAnnouncementResp `json:"data,omitempty"`
}

// GetChatAnnouncementResp ...
type GetChatAnnouncementResp struct {
	Content        string `json:"content,omitempty"`          // 云文档序列化信息
	Revision       string `json:"revision,omitempty"`         // 文档当前版本号 纯数字
	CreateTime     string `json:"create_time,omitempty"`      // 文档生成的时间戳（秒）
	UpdateTime     string `json:"update_time,omitempty"`      // 文档更新的时间戳（秒）
	OwnerIDType    IDType `json:"owner_id_type,omitempty"`    // 文档所有者的 ID 类型, 如果所有者是用户，则与查询参数中的user_id_type 相同；取值为`open_id` `user_id` `union_id` 其中之一，不同 ID 的说明参见 [用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 如果所有者是机器人，为机器人应用的 `app_id`，详情参见  [获取应用身份访问凭证](https://open.feishu.cn/document/ukTMukTMukTM/ukDNz4SO0MjL5QzM/g), 可选值有: `user_id`：以 user_id 来识别用户, `union_id`：以 union_id 来识别用户, `open_id`：以 open_id 来识别用户, `app_id`：以 app_id 来识别机器人应用
	OwnerID        string `json:"owner_id,omitempty"`         // 文档所有者 ID，ID 值与owner_id_type 中的ID类型对应
	ModifierIDType IDType `json:"modifier_id_type,omitempty"` // 文档最新修改者 id 类型, - 如果修改者是用户，则与查询参数中的user_id_type 相同；取值为`open_id` `user_id` `union_id` 其中之一，不同 ID 的说明参见 [用户相关的 ID 概念](https://open.feishu.cn/document/home/user-identity-introduction/introduction), 如果修改者是机器人，为机器人应用的 `app_id`，详情参见  [获取应用身份访问凭证](https://open.feishu.cn/document/ukTMukTMukTM/ukDNz4SO0MjL5QzM/g), 可选值有: `user_id`：以 user_id 来识别用户, `union_id`：以 union_id 来识别用户, `open_id`：以 open_id 来识别用户, `app_id`：以 app_id 来识别应用
	ModifierID     string `json:"modifier_id,omitempty"`      // 文档最新修改者 ID，ID 值与modifier_id_type 中的ID类型对应
}
