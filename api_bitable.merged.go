// Code generated by lark_sdk_gen. DO NOT EDIT.

package lark

import (
	"context"
)

// DeleteBitableField 该接口用于在数据表中删除一个字段
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-field/delete
func (r *BitableService) DeleteBitableField(ctx context.Context, request *DeleteBitableFieldReq, options ...MethodOptionFunc) (*DeleteBitableFieldResp, *Response, error) {
	if r.cli.mock.mockBitableDeleteBitableField != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#DeleteBitableField mock enable")
		return r.cli.mock.mockBitableDeleteBitableField(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "DeleteBitableField",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/fields/:field_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteBitableFieldResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableDeleteBitableField(f func(ctx context.Context, request *DeleteBitableFieldReq, options ...MethodOptionFunc) (*DeleteBitableFieldResp, *Response, error)) {
	r.mockBitableDeleteBitableField = f
}

func (r *Mock) UnMockBitableDeleteBitableField() {
	r.mockBitableDeleteBitableField = nil
}

type DeleteBitableFieldReq struct {
	AppToken string `path:"app_token" json:"-"` // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID  string `path:"table_id" json:"-"`  // table id, 示例值："tblsRc9GRRXKqhvW"
	FieldID  string `path:"field_id" json:"-"`  // field id, 示例值："fldPTb0U2y"
}

type deleteBitableFieldResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *DeleteBitableFieldResp `json:"data,omitempty"`
}

type DeleteBitableFieldResp struct {
	FieldID string `json:"field_id,omitempty"` // field id
	Deleted bool   `json:"deleted,omitempty"`  // 删除标记
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBitableFieldList 根据 app_token 和 table_id，获取数据表的所有字段
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-field/list
func (r *BitableService) GetBitableFieldList(ctx context.Context, request *GetBitableFieldListReq, options ...MethodOptionFunc) (*GetBitableFieldListResp, *Response, error) {
	if r.cli.mock.mockBitableGetBitableFieldList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#GetBitableFieldList mock enable")
		return r.cli.mock.mockBitableGetBitableFieldList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "GetBitableFieldList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/fields",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getBitableFieldListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableGetBitableFieldList(f func(ctx context.Context, request *GetBitableFieldListReq, options ...MethodOptionFunc) (*GetBitableFieldListResp, *Response, error)) {
	r.mockBitableGetBitableFieldList = f
}

func (r *Mock) UnMockBitableGetBitableFieldList() {
	r.mockBitableGetBitableFieldList = nil
}

type GetBitableFieldListReq struct {
	ViewID    *string `query:"view_id" json:"-"`    // 视图 ID, 示例值："vewOVMEXPF"
	PageToken *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："fldwJ4YrtB"
	PageSize  *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`100`
	AppToken  string  `path:"app_token" json:"-"`   // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID   string  `path:"table_id" json:"-"`    // table id, 示例值："tblsRc9GRRXKqhvW"
}

type getBitableFieldListResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *GetBitableFieldListResp `json:"data,omitempty"`
}

type GetBitableFieldListResp struct {
	HasMore   bool                           `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                         `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	Total     int64                          `json:"total,omitempty"`      // 总数
	Items     []*GetBitableFieldListRespItem `json:"items,omitempty"`      // 字段信息
}

type GetBitableFieldListRespItem struct {
	FieldID   string                               `json:"field_id,omitempty"`   // 多维表格字段 id
	FieldName string                               `json:"field_name,omitempty"` // 多维表格字段名
	Type      int64                                `json:"type,omitempty"`       // 多维表格字段类型
	Property  *GetBitableFieldListRespItemProperty `json:"property,omitempty"`   // 字段属性, 具体参考: [Property说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/bitable/development-guide/bitable-structure#b286b4ee)
}

type GetBitableFieldListRespItemProperty struct {
	Options    []*GetBitableFieldListRespItemPropertyOption `json:"options,omitempty"`     // 单选/多选字段的选项信息
	Formatter  string                                       `json:"formatter,omitempty"`   // 数字字段的数字显示格式
	DateFormat string                                       `json:"date_format,omitempty"` // 日期格式
	TimeFormat string                                       `json:"time_format,omitempty"` // 时间格式
	AutoFill   bool                                         `json:"auto_fill,omitempty"`   // 是否自动填入创建时间
	Multiple   bool                                         `json:"multiple,omitempty"`    // 多选标记
	TableID    string                                       `json:"table_id,omitempty"`    // 关联字段中关联表的id
	ViewID     string                                       `json:"view_id,omitempty"`     // 关联字段中关联表的视图id
	Fields     []string                                     `json:"fields,omitempty"`      // 关联字段要展示的字段
}

type GetBitableFieldListRespItemPropertyOption struct {
	Name string `json:"name,omitempty"` // 选项名
	ID   string `json:"id,omitempty"`   // 选项id
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateBitableField 该接口用于在数据表中更新一个字段
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-field/update
func (r *BitableService) UpdateBitableField(ctx context.Context, request *UpdateBitableFieldReq, options ...MethodOptionFunc) (*UpdateBitableFieldResp, *Response, error) {
	if r.cli.mock.mockBitableUpdateBitableField != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#UpdateBitableField mock enable")
		return r.cli.mock.mockBitableUpdateBitableField(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "UpdateBitableField",
		Method:                "PUT",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/fields/:field_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateBitableFieldResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableUpdateBitableField(f func(ctx context.Context, request *UpdateBitableFieldReq, options ...MethodOptionFunc) (*UpdateBitableFieldResp, *Response, error)) {
	r.mockBitableUpdateBitableField = f
}

func (r *Mock) UnMockBitableUpdateBitableField() {
	r.mockBitableUpdateBitableField = nil
}

type UpdateBitableFieldReq struct {
	AppToken  string                         `path:"app_token" json:"-"`   // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID   string                         `path:"table_id" json:"-"`    // table id, 示例值："tblsRc9GRRXKqhvW"
	FieldID   string                         `path:"field_id" json:"-"`    // field id, 示例值："fldPTb0U2y"
	FieldName string                         `json:"field_name,omitempty"` // 多维表格字段名, 示例值："多行文本"
	Type      int64                          `json:"type,omitempty"`       // 多维表格字段类型, 示例值：具体参考: [Property说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/bitable/development-guide/bitable-structure#b286b4ee), 可选值有: `1`：多行文本, `2`：数字, `3`：单选, `4`：多选, `5`：日期, `7`：复选框, `11`：人员, `15`：超链接, `17`：附件, `18`：关联, `20`：公式, `1001`：创建时间, `1002`：最后更新时间, `1003`：创建人, `1004`：修改人
	Property  *UpdateBitableFieldReqProperty `json:"property,omitempty"`   // 字段属性, 具体参考: [Property说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/bitable/development-guide/bitable-structure#b286b4ee)
}

type UpdateBitableFieldReqProperty struct {
	Options    []*UpdateBitableFieldReqPropertyOption `json:"options,omitempty"`     // 单选/多选字段的选项信息
	Formatter  *string                                `json:"formatter,omitempty"`   // 数字字段的数字显示格式, 示例值："0"
	DateFormat *string                                `json:"date_format,omitempty"` // 日期格式, 示例值："yyyy/MM/dd"
	TimeFormat *string                                `json:"time_format,omitempty"` // 时间格式, 示例值："HH:mm"
	AutoFill   *bool                                  `json:"auto_fill,omitempty"`   // 是否自动填入创建时间, 示例值：false
	Multiple   *bool                                  `json:"multiple,omitempty"`    // 多选标记, 示例值：false
	TableID    *string                                `json:"table_id,omitempty"`    // 关联字段中关联表的id, 示例值："tblsRc9GRRXKqhvW"
	ViewID     *string                                `json:"view_id,omitempty"`     // 关联字段中关联表的视图id, 示例值："vewOVMEXPF"
	Fields     []string                               `json:"fields,omitempty"`      // 关联字段要展示的字段, 示例值：["fldSiTwIqy"]
}

type UpdateBitableFieldReqPropertyOption struct {
	Name *string `json:"name,omitempty"` // 选项名, 示例值："红色"
	ID   *string `json:"id,omitempty"`   // 选项id, 示例值："optKl35lnG"
}

type updateBitableFieldResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *UpdateBitableFieldResp `json:"data,omitempty"`
}

type UpdateBitableFieldResp struct {
	Field *UpdateBitableFieldRespField `json:"field,omitempty"` // 字段
}

type UpdateBitableFieldRespField struct {
	FieldID   string                               `json:"field_id,omitempty"`   // 多维表格字段 id
	FieldName string                               `json:"field_name,omitempty"` // 多维表格字段名
	Type      int64                                `json:"type,omitempty"`       // 多维表格字段类型, 可选值有: `1`：多行文本, `2`：数字, `3`：单选, `4`：多选, `5`：日期, `7`：复选框, `11`：人员, `15`：超链接, `17`：附件, `18`：关联, `20`：公式, `1001`：创建时间, `1002`：最后更新时间, `1003`：创建人, `1004`：修改人
	Property  *UpdateBitableFieldRespFieldProperty `json:"property,omitempty"`   // 字段属性, 具体参考: [Property说明](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/bitable/development-guide/bitable-structure#b286b4ee)
}

type UpdateBitableFieldRespFieldProperty struct {
	Options    []*UpdateBitableFieldRespFieldPropertyOption `json:"options,omitempty"`     // 单选/多选字段的选项信息
	Formatter  string                                       `json:"formatter,omitempty"`   // 数字字段的数字显示格式
	DateFormat string                                       `json:"date_format,omitempty"` // 日期格式
	TimeFormat string                                       `json:"time_format,omitempty"` // 时间格式
	AutoFill   bool                                         `json:"auto_fill,omitempty"`   // 是否自动填入创建时间
	Multiple   bool                                         `json:"multiple,omitempty"`    // 多选标记
	TableID    string                                       `json:"table_id,omitempty"`    // 关联字段中关联表的id
	ViewID     string                                       `json:"view_id,omitempty"`     // 关联字段中关联表的视图id
	Fields     []string                                     `json:"fields,omitempty"`      // 关联字段要展示的字段
}

type UpdateBitableFieldRespFieldPropertyOption struct {
	Name string `json:"name,omitempty"` // 选项名
	ID   string `json:"id,omitempty"`   // 选项id
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBitableMeta 通过 app_token 获取多维表格元数据
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app/get
func (r *BitableService) GetBitableMeta(ctx context.Context, request *GetBitableMetaReq, options ...MethodOptionFunc) (*GetBitableMetaResp, *Response, error) {
	if r.cli.mock.mockBitableGetBitableMeta != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#GetBitableMeta mock enable")
		return r.cli.mock.mockBitableGetBitableMeta(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "GetBitableMeta",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getBitableMetaResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableGetBitableMeta(f func(ctx context.Context, request *GetBitableMetaReq, options ...MethodOptionFunc) (*GetBitableMetaResp, *Response, error)) {
	r.mockBitableGetBitableMeta = f
}

func (r *Mock) UnMockBitableGetBitableMeta() {
	r.mockBitableGetBitableMeta = nil
}

type GetBitableMetaReq struct {
	AppToken string `path:"app_token" json:"-"` // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
}

type getBitableMetaResp struct {
	Code int64               `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string              `json:"msg,omitempty"`  // 错误描述
	Data *GetBitableMetaResp `json:"data,omitempty"`
}

type GetBitableMetaResp struct {
	App *GetBitableMetaRespApp `json:"app,omitempty"` // 多维表格元数据
}

type GetBitableMetaRespApp struct {
	AppToken string `json:"app_token,omitempty"` // 多维表格的 app_token
	Name     string `json:"name,omitempty"`      // 多维表格的名字
	Revision int64  `json:"revision,omitempty"`  // 多维表格的版本号
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchCreateBitableRecord 该接口用于在数据表中新增多条记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/batch_create
func (r *BitableService) BatchCreateBitableRecord(ctx context.Context, request *BatchCreateBitableRecordReq, options ...MethodOptionFunc) (*BatchCreateBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableBatchCreateBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#BatchCreateBitableRecord mock enable")
		return r.cli.mock.mockBitableBatchCreateBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "BatchCreateBitableRecord",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records/batch_create",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchCreateBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableBatchCreateBitableRecord(f func(ctx context.Context, request *BatchCreateBitableRecordReq, options ...MethodOptionFunc) (*BatchCreateBitableRecordResp, *Response, error)) {
	r.mockBitableBatchCreateBitableRecord = f
}

func (r *Mock) UnMockBitableBatchCreateBitableRecord() {
	r.mockBitableBatchCreateBitableRecord = nil
}

type BatchCreateBitableRecordReq struct {
	UserIDType *IDType                              `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	AppToken   string                               `path:"app_token" json:"-"`     // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID    string                               `path:"table_id" json:"-"`      // table id, 示例值："tblsRc9GRRXKqhvW"
	Records    []*BatchCreateBitableRecordReqRecord `json:"records,omitempty"`      // 记录
}

type BatchCreateBitableRecordReqRecord struct {
	Fields map[string]interface{} `json:"fields,omitempty"` // 记录字段
}

type batchCreateBitableRecordResp struct {
	Code int64                         `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                        `json:"msg,omitempty"`  // 错误描述
	Data *BatchCreateBitableRecordResp `json:"data,omitempty"`
}

type BatchCreateBitableRecordResp struct {
	Records []*BatchCreateBitableRecordRespRecord `json:"records,omitempty"` // 记录
}

type BatchCreateBitableRecordRespRecord struct {
	RecordID string                 `json:"record_id,omitempty"` // 记录 id
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchDeleteBitableRecord 该接口用于删除数据表中现有的多条记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/batch_delete
func (r *BitableService) BatchDeleteBitableRecord(ctx context.Context, request *BatchDeleteBitableRecordReq, options ...MethodOptionFunc) (*BatchDeleteBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableBatchDeleteBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#BatchDeleteBitableRecord mock enable")
		return r.cli.mock.mockBitableBatchDeleteBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "BatchDeleteBitableRecord",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records/batch_delete",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchDeleteBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableBatchDeleteBitableRecord(f func(ctx context.Context, request *BatchDeleteBitableRecordReq, options ...MethodOptionFunc) (*BatchDeleteBitableRecordResp, *Response, error)) {
	r.mockBitableBatchDeleteBitableRecord = f
}

func (r *Mock) UnMockBitableBatchDeleteBitableRecord() {
	r.mockBitableBatchDeleteBitableRecord = nil
}

type BatchDeleteBitableRecordReq struct {
	AppToken string   `path:"app_token" json:"-"` // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID  string   `path:"table_id" json:"-"`  // table id, 示例值："tblsRc9GRRXKqhvW"
	Records  []string `json:"records,omitempty"`  // 删除的多条记录id列表, 示例值：[,    "recIcJBbvC",,    "recvmiCORa",]
}

type batchDeleteBitableRecordResp struct {
	Code int64                         `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                        `json:"msg,omitempty"`  // 错误描述
	Data *BatchDeleteBitableRecordResp `json:"data,omitempty"`
}

type BatchDeleteBitableRecordResp struct {
	Records []*BatchDeleteBitableRecordRespRecord `json:"records,omitempty"` // 记录
}

type BatchDeleteBitableRecordRespRecord struct {
	Deleted  bool   `json:"deleted,omitempty"`   // 是否成功删除
	RecordID string `json:"record_id,omitempty"` // 删除的记录 ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchUpdateBitableRecord 该接口用于更新数据表中的多条记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/batch_update
func (r *BitableService) BatchUpdateBitableRecord(ctx context.Context, request *BatchUpdateBitableRecordReq, options ...MethodOptionFunc) (*BatchUpdateBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableBatchUpdateBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#BatchUpdateBitableRecord mock enable")
		return r.cli.mock.mockBitableBatchUpdateBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "BatchUpdateBitableRecord",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records/batch_update",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchUpdateBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableBatchUpdateBitableRecord(f func(ctx context.Context, request *BatchUpdateBitableRecordReq, options ...MethodOptionFunc) (*BatchUpdateBitableRecordResp, *Response, error)) {
	r.mockBitableBatchUpdateBitableRecord = f
}

func (r *Mock) UnMockBitableBatchUpdateBitableRecord() {
	r.mockBitableBatchUpdateBitableRecord = nil
}

type BatchUpdateBitableRecordReq struct {
	UserIDType *IDType                              `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	AppToken   string                               `path:"app_token" json:"-"`     // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID    string                               `path:"table_id" json:"-"`      // table id, 示例值："tblsRc9GRRXKqhvW"
	Records    []*BatchUpdateBitableRecordReqRecord `json:"records,omitempty"`      // 记录
}

type BatchUpdateBitableRecordReqRecord struct {
	RecordID *string                `json:"record_id,omitempty"` // 记录 id, 示例值："recqwIwhc6"
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

type batchUpdateBitableRecordResp struct {
	Code int64                         `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                        `json:"msg,omitempty"`  // 错误描述
	Data *BatchUpdateBitableRecordResp `json:"data,omitempty"`
}

type BatchUpdateBitableRecordResp struct {
	Records []*BatchUpdateBitableRecordRespRecord `json:"records,omitempty"` // 记录
}

type BatchUpdateBitableRecordRespRecord struct {
	RecordID string                 `json:"record_id,omitempty"` // 记录 id
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateBitableRecord 该接口用于在数据表中新增一条记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/create
func (r *BitableService) CreateBitableRecord(ctx context.Context, request *CreateBitableRecordReq, options ...MethodOptionFunc) (*CreateBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableCreateBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#CreateBitableRecord mock enable")
		return r.cli.mock.mockBitableCreateBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "CreateBitableRecord",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableCreateBitableRecord(f func(ctx context.Context, request *CreateBitableRecordReq, options ...MethodOptionFunc) (*CreateBitableRecordResp, *Response, error)) {
	r.mockBitableCreateBitableRecord = f
}

func (r *Mock) UnMockBitableCreateBitableRecord() {
	r.mockBitableCreateBitableRecord = nil
}

type CreateBitableRecordReq struct {
	UserIDType *IDType                `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	AppToken   string                 `path:"app_token" json:"-"`     // bitable app token, 示例值："bascng7vrxcxpig7geggXiCtadY"
	TableID    string                 `path:"table_id" json:"-"`      // table id, 示例值："tblUa9vcYjWQYJCj"
	Fields     map[string]interface{} `json:"fields,omitempty"`       // 记录字段
}

type createBitableRecordResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *CreateBitableRecordResp `json:"data,omitempty"`
}

type CreateBitableRecordResp struct {
	Record *CreateBitableRecordRespRecord `json:"record,omitempty"` // 记录
}

type CreateBitableRecordRespRecord struct {
	RecordID string                 `json:"record_id,omitempty"` // 记录 id
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteBitableRecord 该接口用于删除数据表中的一条记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/delete
func (r *BitableService) DeleteBitableRecord(ctx context.Context, request *DeleteBitableRecordReq, options ...MethodOptionFunc) (*DeleteBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableDeleteBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#DeleteBitableRecord mock enable")
		return r.cli.mock.mockBitableDeleteBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "DeleteBitableRecord",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records/:record_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableDeleteBitableRecord(f func(ctx context.Context, request *DeleteBitableRecordReq, options ...MethodOptionFunc) (*DeleteBitableRecordResp, *Response, error)) {
	r.mockBitableDeleteBitableRecord = f
}

func (r *Mock) UnMockBitableDeleteBitableRecord() {
	r.mockBitableDeleteBitableRecord = nil
}

type DeleteBitableRecordReq struct {
	AppToken string `path:"app_token" json:"-"` // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID  string `path:"table_id" json:"-"`  // table id, 示例值："tblsRc9GRRXKqhvW"
	RecordID string `path:"record_id" json:"-"` // 单条记录的Id, 示例值："recpCsf4ME"
}

type deleteBitableRecordResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *DeleteBitableRecordResp `json:"data,omitempty"`
}

type DeleteBitableRecordResp struct {
	Deleted  bool   `json:"deleted,omitempty"`   // 是否成功删除
	RecordID string `json:"record_id,omitempty"` // 删除的记录 ID
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBitableRecord 该接口用于根据 record_id 的值检索现有记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/get
func (r *BitableService) GetBitableRecord(ctx context.Context, request *GetBitableRecordReq, options ...MethodOptionFunc) (*GetBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableGetBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#GetBitableRecord mock enable")
		return r.cli.mock.mockBitableGetBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "GetBitableRecord",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records/:record_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableGetBitableRecord(f func(ctx context.Context, request *GetBitableRecordReq, options ...MethodOptionFunc) (*GetBitableRecordResp, *Response, error)) {
	r.mockBitableGetBitableRecord = f
}

func (r *Mock) UnMockBitableGetBitableRecord() {
	r.mockBitableGetBitableRecord = nil
}

type GetBitableRecordReq struct {
	TextFieldAsArray *bool   `query:"text_field_as_array" json:"-"` // 控制多行文本字段数据的返回格式, true 表示以数组形式返回, 示例值：true
	UserIDType       *IDType `query:"user_id_type" json:"-"`        // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	AppToken         string  `path:"app_token" json:"-"`            // bitable app token, 示例值："bascnCMII2ORej2RItqpZZUNMIe"
	TableID          string  `path:"table_id" json:"-"`             // table id, 示例值："tblxI2tWaxP5dG7p"
	RecordID         string  `path:"record_id" json:"-"`            // 单条记录的 id, 示例值："recn0hoyXL"
}

type getBitableRecordResp struct {
	Code int64                 `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                `json:"msg,omitempty"`  // 错误描述
	Data *GetBitableRecordResp `json:"data,omitempty"`
}

type GetBitableRecordResp struct {
	Record *GetBitableRecordRespRecord `json:"record,omitempty"` // 记录
}

type GetBitableRecordRespRecord struct {
	RecordID string                 `json:"record_id,omitempty"` // 记录 id
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBitableRecordList 该接口用于列出数据表中的现有记录，单次最多列出 100 行记录，支持分页获取。
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/list
func (r *BitableService) GetBitableRecordList(ctx context.Context, request *GetBitableRecordListReq, options ...MethodOptionFunc) (*GetBitableRecordListResp, *Response, error) {
	if r.cli.mock.mockBitableGetBitableRecordList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#GetBitableRecordList mock enable")
		return r.cli.mock.mockBitableGetBitableRecordList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "GetBitableRecordList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getBitableRecordListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableGetBitableRecordList(f func(ctx context.Context, request *GetBitableRecordListReq, options ...MethodOptionFunc) (*GetBitableRecordListResp, *Response, error)) {
	r.mockBitableGetBitableRecordList = f
}

func (r *Mock) UnMockBitableGetBitableRecordList() {
	r.mockBitableGetBitableRecordList = nil
}

type GetBitableRecordListReq struct {
	ViewID           *string `query:"view_id" json:"-"`             // 视图 id, 如filter或sort有值, view_id会被忽略, 示例值："vewqhz51lk"
	Filter           *string `query:"filter" json:"-"`              // filter, 不超过2000个字符, 不支持对带特殊字段(关联和公式)的表的使用, 示例值："AND(CurrentValue.[身高]>180, CurrentValue.[体重]>150)"
	Sort             *string `query:"sort" json:"-"`                // sort, 不超过1000字符, 不支持对带特殊字段(关联和公式)的表的使用, 示例值："["字段1 DESC","字段2 ASC"]"
	FieldNames       *string `query:"field_names" json:"-"`         // field_names, 示例值："["字段1"]"
	TextFieldAsArray *bool   `query:"text_field_as_array" json:"-"` // 控制多行文本字段数据的返回格式, true 表示以数组形式返回, 示例值：true
	PageToken        *string `query:"page_token" json:"-"`          // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："recn0hoyXL"
	PageSize         *int64  `query:"page_size" json:"-"`           // 分页大小, 示例值：10, 最大值：`100`
	UserIDType       *IDType `query:"user_id_type" json:"-"`        // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	AppToken         string  `path:"app_token" json:"-"`            // bitable app token, 示例值："bascnCMII2ORej2RItqpZZUNMIe"
	TableID          string  `path:"table_id" json:"-"`             // table id, 示例值："tblxI2tWaxP5dG7p"
}

type getBitableRecordListResp struct {
	Code int64                     `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                    `json:"msg,omitempty"`  // 错误描述
	Data *GetBitableRecordListResp `json:"data,omitempty"`
}

type GetBitableRecordListResp struct {
	HasMore   bool                            `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                          `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	Total     int64                           `json:"total,omitempty"`      // 总数
	Items     []*GetBitableRecordListRespItem `json:"items,omitempty"`      // 记录信息
}

type GetBitableRecordListRespItem struct {
	RecordID string                 `json:"record_id,omitempty"` // 记录 id
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// UpdateBitableRecord 该接口用于更新数据表中的一条记录
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-record/update
func (r *BitableService) UpdateBitableRecord(ctx context.Context, request *UpdateBitableRecordReq, options ...MethodOptionFunc) (*UpdateBitableRecordResp, *Response, error) {
	if r.cli.mock.mockBitableUpdateBitableRecord != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#UpdateBitableRecord mock enable")
		return r.cli.mock.mockBitableUpdateBitableRecord(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "UpdateBitableRecord",
		Method:                "PUT",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records/:record_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(updateBitableRecordResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableUpdateBitableRecord(f func(ctx context.Context, request *UpdateBitableRecordReq, options ...MethodOptionFunc) (*UpdateBitableRecordResp, *Response, error)) {
	r.mockBitableUpdateBitableRecord = f
}

func (r *Mock) UnMockBitableUpdateBitableRecord() {
	r.mockBitableUpdateBitableRecord = nil
}

type UpdateBitableRecordReq struct {
	UserIDType *IDType                `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求:  获取用户 user ID
	AppToken   string                 `path:"app_token" json:"-"`     // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID    string                 `path:"table_id" json:"-"`      // table id, 示例值："tblsRc9GRRXKqhvW"
	RecordID   string                 `path:"record_id" json:"-"`     // 单条记录的 id, 示例值："recqwIwhc6"
	Fields     map[string]interface{} `json:"fields,omitempty"`       // 记录字段
}

type updateBitableRecordResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *UpdateBitableRecordResp `json:"data,omitempty"`
}

type UpdateBitableRecordResp struct {
	Record *UpdateBitableRecordRespRecord `json:"record,omitempty"` // {,    "fields": {,        "人力评估": 2,,        "任务执行人": [,            {,                "id": "ou_debc524b2d8cb187704df652b43d29de",            },        ],,        "任务描述": "多渠道收集用户反馈",,        "对应 OKR": [,            "recqwIwhc6",,            "recOuEJMvN",        ],,        "截止日期": 1609516800000,,        "是否完成": true,,        "状态": "已结束",,        "相关部门": [,            "销售",,            "客服",        ],    },}
}

type UpdateBitableRecordRespRecord struct {
	RecordID string                 `json:"record_id,omitempty"` // 记录 id
	Fields   map[string]interface{} `json:"fields,omitempty"`    // 记录字段
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchCreateBitableTable 新增多个数据表
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table/batch_create
func (r *BitableService) BatchCreateBitableTable(ctx context.Context, request *BatchCreateBitableTableReq, options ...MethodOptionFunc) (*BatchCreateBitableTableResp, *Response, error) {
	if r.cli.mock.mockBitableBatchCreateBitableTable != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#BatchCreateBitableTable mock enable")
		return r.cli.mock.mockBitableBatchCreateBitableTable(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "BatchCreateBitableTable",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/batch_create",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchCreateBitableTableResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableBatchCreateBitableTable(f func(ctx context.Context, request *BatchCreateBitableTableReq, options ...MethodOptionFunc) (*BatchCreateBitableTableResp, *Response, error)) {
	r.mockBitableBatchCreateBitableTable = f
}

func (r *Mock) UnMockBitableBatchCreateBitableTable() {
	r.mockBitableBatchCreateBitableTable = nil
}

type BatchCreateBitableTableReq struct {
	UserIDType *IDType                            `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	AppToken   string                             `path:"app_token" json:"-"`     // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	Tables     []*BatchCreateBitableTableReqTable `json:"tables,omitempty"`       // tables
}

type BatchCreateBitableTableReqTable struct {
	Name *string `json:"name,omitempty"` // 数据表 名字, 示例值："table1"
}

type batchCreateBitableTableResp struct {
	Code int64                        `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                       `json:"msg,omitempty"`  // 错误描述
	Data *BatchCreateBitableTableResp `json:"data,omitempty"`
}

type BatchCreateBitableTableResp struct {
	TableIDs []string `json:"table_ids,omitempty"` // table ids
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// BatchDeleteBitableTable 删除多个数据表
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table/batch_delete
func (r *BitableService) BatchDeleteBitableTable(ctx context.Context, request *BatchDeleteBitableTableReq, options ...MethodOptionFunc) (*BatchDeleteBitableTableResp, *Response, error) {
	if r.cli.mock.mockBitableBatchDeleteBitableTable != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#BatchDeleteBitableTable mock enable")
		return r.cli.mock.mockBitableBatchDeleteBitableTable(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "BatchDeleteBitableTable",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/batch_delete",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(batchDeleteBitableTableResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableBatchDeleteBitableTable(f func(ctx context.Context, request *BatchDeleteBitableTableReq, options ...MethodOptionFunc) (*BatchDeleteBitableTableResp, *Response, error)) {
	r.mockBitableBatchDeleteBitableTable = f
}

func (r *Mock) UnMockBitableBatchDeleteBitableTable() {
	r.mockBitableBatchDeleteBitableTable = nil
}

type BatchDeleteBitableTableReq struct {
	AppToken string   `path:"app_token" json:"-"`  // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableIDs []string `json:"table_ids,omitempty"` // 删除的多条tableid列表
}

type batchDeleteBitableTableResp struct {
	Code int64                        `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                       `json:"msg,omitempty"`  // 错误描述
	Data *BatchDeleteBitableTableResp `json:"data,omitempty"`
}

type BatchDeleteBitableTableResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateBitableTable 新增一个数据表
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table/create
func (r *BitableService) CreateBitableTable(ctx context.Context, request *CreateBitableTableReq, options ...MethodOptionFunc) (*CreateBitableTableResp, *Response, error) {
	if r.cli.mock.mockBitableCreateBitableTable != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#CreateBitableTable mock enable")
		return r.cli.mock.mockBitableCreateBitableTable(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "CreateBitableTable",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createBitableTableResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableCreateBitableTable(f func(ctx context.Context, request *CreateBitableTableReq, options ...MethodOptionFunc) (*CreateBitableTableResp, *Response, error)) {
	r.mockBitableCreateBitableTable = f
}

func (r *Mock) UnMockBitableCreateBitableTable() {
	r.mockBitableCreateBitableTable = nil
}

type CreateBitableTableReq struct {
	UserIDType *IDType                     `query:"user_id_type" json:"-"` // 用户 ID 类型, 示例值："open_id", 可选值有: `open_id`：用户的 open id, `union_id`：用户的 union id, `user_id`：用户的 user id, 默认值: `open_id`, 当值为 `user_id`, 字段权限要求: 获取用户 user ID
	AppToken   string                      `path:"app_token" json:"-"`     // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	Table      *CreateBitableTableReqTable `json:"table,omitempty"`        // 数据表
}

type CreateBitableTableReqTable struct {
	Name *string `json:"name,omitempty"` // 数据表 名字, 示例值："table1"
}

type createBitableTableResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *CreateBitableTableResp `json:"data,omitempty"`
}

type CreateBitableTableResp struct {
	TableID string `json:"table_id,omitempty"` // table id
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteBitableTable 删除一个数据表
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table/delete
func (r *BitableService) DeleteBitableTable(ctx context.Context, request *DeleteBitableTableReq, options ...MethodOptionFunc) (*DeleteBitableTableResp, *Response, error) {
	if r.cli.mock.mockBitableDeleteBitableTable != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#DeleteBitableTable mock enable")
		return r.cli.mock.mockBitableDeleteBitableTable(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "DeleteBitableTable",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteBitableTableResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableDeleteBitableTable(f func(ctx context.Context, request *DeleteBitableTableReq, options ...MethodOptionFunc) (*DeleteBitableTableResp, *Response, error)) {
	r.mockBitableDeleteBitableTable = f
}

func (r *Mock) UnMockBitableDeleteBitableTable() {
	r.mockBitableDeleteBitableTable = nil
}

type DeleteBitableTableReq struct {
	AppToken string `path:"app_token" json:"-"` // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID  string `path:"table_id" json:"-"`  // table id, 示例值："tblsRc9GRRXKqhvW"
}

type deleteBitableTableResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *DeleteBitableTableResp `json:"data,omitempty"`
}

type DeleteBitableTableResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBitableTableList 根据  app_token，获取多维表格下的所有数据表
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table/list
func (r *BitableService) GetBitableTableList(ctx context.Context, request *GetBitableTableListReq, options ...MethodOptionFunc) (*GetBitableTableListResp, *Response, error) {
	if r.cli.mock.mockBitableGetBitableTableList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#GetBitableTableList mock enable")
		return r.cli.mock.mockBitableGetBitableTableList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "GetBitableTableList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getBitableTableListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableGetBitableTableList(f func(ctx context.Context, request *GetBitableTableListReq, options ...MethodOptionFunc) (*GetBitableTableListResp, *Response, error)) {
	r.mockBitableGetBitableTableList = f
}

func (r *Mock) UnMockBitableGetBitableTableList() {
	r.mockBitableGetBitableTableList = nil
}

type GetBitableTableListReq struct {
	PageToken *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："tblsRc9GRRXKqhvW"
	PageSize  *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`100`
	AppToken  string  `path:"app_token" json:"-"`   // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
}

type getBitableTableListResp struct {
	Code int64                    `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                   `json:"msg,omitempty"`  // 错误描述
	Data *GetBitableTableListResp `json:"data,omitempty"`
}

type GetBitableTableListResp struct {
	HasMore   bool                           `json:"has_more,omitempty"`   // 是否还有更多项
	PageToken string                         `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	Total     int64                          `json:"total,omitempty"`      // 总数
	Items     []*GetBitableTableListRespItem `json:"items,omitempty"`      // 数据表信息
}

type GetBitableTableListRespItem struct {
	TableID  string `json:"table_id,omitempty"` // 数据表 id
	Revision int64  `json:"revision,omitempty"` // 数据表的版本号
	Name     string `json:"name,omitempty"`     // 数据表名字
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// CreateBitableView 在数据表中新增一个视图
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-view/create
func (r *BitableService) CreateBitableView(ctx context.Context, request *CreateBitableViewReq, options ...MethodOptionFunc) (*CreateBitableViewResp, *Response, error) {
	if r.cli.mock.mockBitableCreateBitableView != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#CreateBitableView mock enable")
		return r.cli.mock.mockBitableCreateBitableView(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "CreateBitableView",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/views",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(createBitableViewResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableCreateBitableView(f func(ctx context.Context, request *CreateBitableViewReq, options ...MethodOptionFunc) (*CreateBitableViewResp, *Response, error)) {
	r.mockBitableCreateBitableView = f
}

func (r *Mock) UnMockBitableCreateBitableView() {
	r.mockBitableCreateBitableView = nil
}

type CreateBitableViewReq struct {
	AppToken string  `path:"app_token" json:"-"`  // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID  string  `path:"table_id" json:"-"`   // table id, 示例值："tblsRc9GRRXKqhvW"
	ViewID   *string `json:"view_id,omitempty"`   // 视图Id, 示例值："vewTpR1urY"
	ViewName *string `json:"view_name,omitempty"` // 视图名字, 示例值："甘特视图1"
	ViewType *string `json:"view_type,omitempty"` // 视图类型, 示例值："gantt"
}

type createBitableViewResp struct {
	Code int64                  `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 错误描述
	Data *CreateBitableViewResp `json:"data,omitempty"`
}

type CreateBitableViewResp struct {
	View *CreateBitableViewRespApptableview `json:"view,omitempty"` // 视图
}

type CreateBitableViewRespApptableview struct {
	ViewID   string `json:"view_id,omitempty"`   // 视图Id
	ViewName string `json:"view_name,omitempty"` // 视图名字
	ViewType string `json:"view_type,omitempty"` // 视图类型
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// DeleteBitableView 删除数据表中的视图
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-view/delete
func (r *BitableService) DeleteBitableView(ctx context.Context, request *DeleteBitableViewReq, options ...MethodOptionFunc) (*DeleteBitableViewResp, *Response, error) {
	if r.cli.mock.mockBitableDeleteBitableView != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#DeleteBitableView mock enable")
		return r.cli.mock.mockBitableDeleteBitableView(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "DeleteBitableView",
		Method:                "DELETE",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/views/:view_id",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(deleteBitableViewResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableDeleteBitableView(f func(ctx context.Context, request *DeleteBitableViewReq, options ...MethodOptionFunc) (*DeleteBitableViewResp, *Response, error)) {
	r.mockBitableDeleteBitableView = f
}

func (r *Mock) UnMockBitableDeleteBitableView() {
	r.mockBitableDeleteBitableView = nil
}

type DeleteBitableViewReq struct {
	AppToken string `path:"app_token" json:"-"` // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID  string `path:"table_id" json:"-"`  // table id, 示例值："tblsRc9GRRXKqhvW"
	ViewID   string `path:"view_id" json:"-"`   // 视图Id, 示例值："vewTpR1urY"
}

type deleteBitableViewResp struct {
	Code int64                  `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                 `json:"msg,omitempty"`  // 错误描述
	Data *DeleteBitableViewResp `json:"data,omitempty"`
}

type DeleteBitableViewResp struct{}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// GetBitableViewList 根据 app_token 和 table_id，获取数据表的所有视图
//
// doc: https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/bitable-v1/app-table-view/list
func (r *BitableService) GetBitableViewList(ctx context.Context, request *GetBitableViewListReq, options ...MethodOptionFunc) (*GetBitableViewListResp, *Response, error) {
	if r.cli.mock.mockBitableGetBitableViewList != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bitable#GetBitableViewList mock enable")
		return r.cli.mock.mockBitableGetBitableViewList(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bitable",
		API:                   "GetBitableViewList",
		Method:                "GET",
		URL:                   r.cli.openBaseURL + "/open-apis/bitable/v1/apps/:app_token/tables/:table_id/views",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
		NeedUserAccessToken:   true,
	}
	resp := new(getBitableViewListResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBitableGetBitableViewList(f func(ctx context.Context, request *GetBitableViewListReq, options ...MethodOptionFunc) (*GetBitableViewListResp, *Response, error)) {
	r.mockBitableGetBitableViewList = f
}

func (r *Mock) UnMockBitableGetBitableViewList() {
	r.mockBitableGetBitableViewList = nil
}

type GetBitableViewListReq struct {
	PageSize  *int64  `query:"page_size" json:"-"`  // 分页大小, 示例值：10, 最大值：`100`
	PageToken *string `query:"page_token" json:"-"` // 分页标记，第一次请求不填，表示从头开始遍历；分页查询结果还有更多项时会同时返回新的 page_token，下次遍历可采用该 page_token 获取查询结果, 示例值："vewTpR1urY"
	AppToken  string  `path:"app_token" json:"-"`   // bitable app token, 示例值："appbcbWCzen6D8dezhoCH2RpMAh"
	TableID   string  `path:"table_id" json:"-"`    // table id, 示例值："tblsRc9GRRXKqhvW"
}

type getBitableViewListResp struct {
	Code int64                   `json:"code,omitempty"` // 错误码，非 0 表示失败
	Msg  string                  `json:"msg,omitempty"`  // 错误描述
	Data *GetBitableViewListResp `json:"data,omitempty"`
}

type GetBitableViewListResp struct {
	Items     []*GetBitableViewListRespItem `json:"items,omitempty"`      // 视图信息
	PageToken string                        `json:"page_token,omitempty"` // 分页标记，当 has_more 为 true 时，会同时返回新的 page_token，否则不返回 page_token
	HasMore   bool                          `json:"has_more,omitempty"`   // 是否还有更多项
	Total     int64                         `json:"total,omitempty"`      // 总数
}

type GetBitableViewListRespItem struct {
	ViewID   string `json:"view_id,omitempty"`   // 视图Id
	ViewName string `json:"view_name,omitempty"` // 视图名字
	ViewType string `json:"view_type,omitempty"` // 视图类型
}

// Code generated by lark_sdk_gen. DO NOT EDIT.

// AddBotToChat
//
// 为了更好地提升该接口的安全性，我们对其进行了升级，请尽快迁移至[新版本>>](https://open.feishu.cn/document/uAjLw4CM/ukTMukTMukTM/reference/im-v1/chat-members/create)
// 拉机器人进群<br>
// **权限说明** ：需要启用机器人能力；机器人的owner需要已经在群里
//
// doc: https://open.feishu.cn/document/ukTMukTMukTM/uYDO04iN4QjL2gDN
//
// Deprecated
func (r *BotService) AddBotToChat(ctx context.Context, request *AddBotToChatReq, options ...MethodOptionFunc) (*AddBotToChatResp, *Response, error) {
	if r.cli.mock.mockBotAddBotToChat != nil {
		r.cli.log(ctx, LogLevelDebug, "[lark] Bot#AddBotToChat mock enable")
		return r.cli.mock.mockBotAddBotToChat(ctx, request, options...)
	}

	req := &RawRequestReq{
		Scope:                 "Bot",
		API:                   "AddBotToChat",
		Method:                "POST",
		URL:                   r.cli.openBaseURL + "/open-apis/bot/v4/add",
		Body:                  request,
		MethodOption:          newMethodOption(options),
		NeedTenantAccessToken: true,
	}
	resp := new(addBotToChatResp)

	response, err := r.cli.RawRequest(ctx, req, resp)
	return resp.Data, response, err
}

func (r *Mock) MockBotAddBotToChat(f func(ctx context.Context, request *AddBotToChatReq, options ...MethodOptionFunc) (*AddBotToChatResp, *Response, error)) {
	r.mockBotAddBotToChat = f
}

func (r *Mock) UnMockBotAddBotToChat() {
	r.mockBotAddBotToChat = nil
}

type AddBotToChatReq struct {
	ChatID string `json:"chat_id,omitempty"` // 群的id
}

type addBotToChatResp struct {
	Code int64             `json:"code,omitempty"` // 返回码，非 0 表示失败
	Msg  string            `json:"msg,omitempty"`  // 返回码描述
	Data *AddBotToChatResp `json:"data,omitempty"`
}

type AddBotToChatResp struct{}
